{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Stories \u00b6 Service objects designed with OOP in mind. Documentation | Source Code | Task Tracker A paragraph of text explaining the goal of the library\u2026 Pros \u00b6 A feature B feature etc Example \u00b6 A line of text explaining snippet below\u2026 >>> from dataclasses import dataclass >>> from typing import Callable >>> from stories import Story , I , State >>> from app.repositories import load_order , load_customer , create_payment >>> @dataclass ... class Purchase ( Story ): ... I . find_order ... I . find_customer ... I . check_balance ... I . persist_payment ... ... def find_order ( self , state ): ... state . order = self . load_order ( state . order_id ) ... ... def find_customer ( self , state ): ... state . customer = self . load_customer ( state . customer_id ) ... ... def check_balance ( self , state ): ... if not state . order . affordable_for ( state . customer ): ... raise Exception ... ... def persist_payment ( self , state ): ... state . payment = self . create_payment ( ... order_id = state . order_id , customer_id = state . customer_id ... ) ... ... load_order : Callable ... load_customer : Callable ... create_payment : Callable >>> purchase = Purchase ( ... load_order = load_order , ... load_customer = load_customer , ... create_payment = create_payment , ... ) >>> state = State ( order_id = 1 , customer_id = 1 ) >>> purchase ( state ) >>> state # doctest: +SKIP >>> state . payment . was_received () False Questions \u00b6 If you have any questions, feel free to create an issue in our Task Tracker . We have the question label exactly for this purpose. Enterprise support \u00b6 If you have an issue with any version of the library, you can apply for a paid enterprise support contract. This will guarantee you that no breaking changes will happen to you. No matter how old version you're using at the moment. All necessary features and bug fixes will be backported in a way that serves your needs. Please contact proofit404@gmail.com if you're interested in it. License \u00b6 stories library is offered under the two clause BSD license. \u2014 \u2b50 \u2014","title":"Home"},{"location":"#stories","text":"Service objects designed with OOP in mind. Documentation | Source Code | Task Tracker A paragraph of text explaining the goal of the library\u2026","title":"Stories"},{"location":"#pros","text":"A feature B feature etc","title":"Pros"},{"location":"#example","text":"A line of text explaining snippet below\u2026 >>> from dataclasses import dataclass >>> from typing import Callable >>> from stories import Story , I , State >>> from app.repositories import load_order , load_customer , create_payment >>> @dataclass ... class Purchase ( Story ): ... I . find_order ... I . find_customer ... I . check_balance ... I . persist_payment ... ... def find_order ( self , state ): ... state . order = self . load_order ( state . order_id ) ... ... def find_customer ( self , state ): ... state . customer = self . load_customer ( state . customer_id ) ... ... def check_balance ( self , state ): ... if not state . order . affordable_for ( state . customer ): ... raise Exception ... ... def persist_payment ( self , state ): ... state . payment = self . create_payment ( ... order_id = state . order_id , customer_id = state . customer_id ... ) ... ... load_order : Callable ... load_customer : Callable ... create_payment : Callable >>> purchase = Purchase ( ... load_order = load_order , ... load_customer = load_customer , ... create_payment = create_payment , ... ) >>> state = State ( order_id = 1 , customer_id = 1 ) >>> purchase ( state ) >>> state # doctest: +SKIP >>> state . payment . was_received () False","title":"Example"},{"location":"#questions","text":"If you have any questions, feel free to create an issue in our Task Tracker . We have the question label exactly for this purpose.","title":"Questions"},{"location":"#enterprise-support","text":"If you have an issue with any version of the library, you can apply for a paid enterprise support contract. This will guarantee you that no breaking changes will happen to you. No matter how old version you're using at the moment. All necessary features and bug fixes will be backported in a way that serves your needs. Please contact proofit404@gmail.com if you're interested in it.","title":"Enterprise support"},{"location":"#license","text":"stories library is offered under the two clause BSD license. \u2014 \u2b50 \u2014","title":"License"},{"location":"actor/","text":"Actor \u00b6 Principles \u00b6 Story could define an actor Story could define an actor \u00b6 Complicated business process is always a composition of smaller business processes. Sometimes these smaller processes would be executed by different persons in real life. Or by people with different roles. To make it easier for the reader of your code to understand who is I in current story you could define an actor as part of the story class. Our general advice would be always define story actors even if you system only has single role at the moment. This small change would give right context for the reader. And please do not call it User . It is always a user. sync >>> from dataclasses import dataclass >>> from typing import Callable >>> from stories import Story , I , State , Actor >>> from app.repositories import load_order , load_customer , create_payment >>> class Customer ( Actor ): ... ... >>> @dataclass ... class Purchase ( Story , Customer ): ... I . find_order ... I . find_customer ... I . check_balance ... I . persist_payment ... ... def find_order ( self , state ): ... state . order = self . load_order ( state . order_id ) ... ... def find_customer ( self , state ): ... state . customer = self . load_customer ( state . customer_id ) ... ... def check_balance ( self , state ): ... if not state . order . affordable_for ( state . customer ): ... raise Exception ... ... def persist_payment ( self , state ): ... state . payment = self . create_payment ( ... order_id = state . order_id , customer_id = state . customer_id ... ) ... ... load_order : Callable ... load_customer : Callable ... create_payment : Callable >>> purchase = Purchase ( ... load_order = load_order , ... load_customer = load_customer , ... create_payment = create_payment , ... ) >>> state = State ( order_id = 1 , customer_id = 1 ) >>> purchase ( state ) async >>> import asyncio >>> from dataclasses import dataclass >>> from typing import Coroutine >>> from stories import Story , I , State , Actor >>> from aioapp.repositories import load_order , load_customer , create_payment >>> class Customer ( Actor ): ... ... >>> @dataclass ... class Purchase ( Story , Customer ): ... I . find_order ... I . find_customer ... I . check_balance ... I . persist_payment ... ... async def find_order ( self , state ): ... state . order = await self . load_order ( state . order_id ) ... ... async def find_customer ( self , state ): ... state . customer = await self . load_customer ( state . customer_id ) ... ... async def check_balance ( self , state ): ... if not state . order . affordable_for ( state . customer ): ... raise Exception ... ... async def persist_payment ( self , state ): ... state . payment = await self . create_payment ( ... order_id = state . order_id , customer_id = state . customer_id ... ) ... ... load_order : Coroutine ... load_customer : Coroutine ... create_payment : Coroutine >>> purchase = Purchase ( ... load_order = load_order , ... load_customer = load_customer , ... create_payment = create_payment , ... ) >>> state = State ( order_id = 1 , customer_id = 1 ) >>> asyncio . run ( purchase ( state )) \u2014 \u2b50 \u2014","title":"Actor"},{"location":"actor/#actor","text":"","title":"Actor"},{"location":"actor/#principles","text":"Story could define an actor","title":"Principles"},{"location":"actor/#story-could-define-an-actor","text":"Complicated business process is always a composition of smaller business processes. Sometimes these smaller processes would be executed by different persons in real life. Or by people with different roles. To make it easier for the reader of your code to understand who is I in current story you could define an actor as part of the story class. Our general advice would be always define story actors even if you system only has single role at the moment. This small change would give right context for the reader. And please do not call it User . It is always a user. sync >>> from dataclasses import dataclass >>> from typing import Callable >>> from stories import Story , I , State , Actor >>> from app.repositories import load_order , load_customer , create_payment >>> class Customer ( Actor ): ... ... >>> @dataclass ... class Purchase ( Story , Customer ): ... I . find_order ... I . find_customer ... I . check_balance ... I . persist_payment ... ... def find_order ( self , state ): ... state . order = self . load_order ( state . order_id ) ... ... def find_customer ( self , state ): ... state . customer = self . load_customer ( state . customer_id ) ... ... def check_balance ( self , state ): ... if not state . order . affordable_for ( state . customer ): ... raise Exception ... ... def persist_payment ( self , state ): ... state . payment = self . create_payment ( ... order_id = state . order_id , customer_id = state . customer_id ... ) ... ... load_order : Callable ... load_customer : Callable ... create_payment : Callable >>> purchase = Purchase ( ... load_order = load_order , ... load_customer = load_customer , ... create_payment = create_payment , ... ) >>> state = State ( order_id = 1 , customer_id = 1 ) >>> purchase ( state ) async >>> import asyncio >>> from dataclasses import dataclass >>> from typing import Coroutine >>> from stories import Story , I , State , Actor >>> from aioapp.repositories import load_order , load_customer , create_payment >>> class Customer ( Actor ): ... ... >>> @dataclass ... class Purchase ( Story , Customer ): ... I . find_order ... I . find_customer ... I . check_balance ... I . persist_payment ... ... async def find_order ( self , state ): ... state . order = await self . load_order ( state . order_id ) ... ... async def find_customer ( self , state ): ... state . customer = await self . load_customer ( state . customer_id ) ... ... async def check_balance ( self , state ): ... if not state . order . affordable_for ( state . customer ): ... raise Exception ... ... async def persist_payment ( self , state ): ... state . payment = await self . create_payment ( ... order_id = state . order_id , customer_id = state . customer_id ... ) ... ... load_order : Coroutine ... load_customer : Coroutine ... create_payment : Coroutine >>> purchase = Purchase ( ... load_order = load_order , ... load_customer = load_customer , ... create_payment = create_payment , ... ) >>> state = State ( order_id = 1 , customer_id = 1 ) >>> asyncio . run ( purchase ( state )) \u2014 \u2b50 \u2014","title":"Story could define an actor"},{"location":"changelog/","text":"5.1.0 (2022-10-14) \u00b6 Features \u00b6 story could define its actor #696 5547ada 5.0.0 (2022-07-21) \u00b6 Code Refactoring \u00b6 earthquake #627 f2b793f Features \u00b6 add argument and variable placeholders #704 24ed603 declare argument including validation #605 ccc0308 declare argument without validation #602 a599aec declare variable including validation #606 670f879 declare variable without validation #591 d760230 deny to assign undeclared variable #680 b1a99aa deny to pass undeclared arguments #681 9705232 execute steps in given order #664 076c656 implement @initiate decorator #324 f747b5d implement @initiate restrictions #649 d4d24d4 propagate exceptions #631 fbb87b4 state union merge variable validators #688 cf9afc4 story call should return none #630 0622d21 story steps could assign state variable #693 0c30861 BREAKING CHANGES \u00b6 The old codebase was removed. The library was redesigned from scratch. A lot of existed functionality was removed. Contrib integrations was moved to separate repositories. The goal of the library stays the same. Allow to express domain knowledge inside codebase with minimal friction. The approach we took is similar with the old one but most of design flaws was fixed in new version. 4.1.0 (2020-11-20) \u00b6 Features \u00b6 support pypy interpreter #42 ( 08fe88a ) 4.0.0 (2020-11-12) \u00b6 Build System \u00b6 add python 3.9 support #553 ( a48fec7 ) BREAKING CHANGES \u00b6 drop python 3.6 support. 3.0.0 (2020-10-01) \u00b6 Features \u00b6 rename Skip marker to Next marker #141 ( 5799aef ) BREAKING CHANGES \u00b6 All usage of the Skip() marker should be replaced with Next() marker. 2.0.0 (2020-08-30) \u00b6 Code Refactoring \u00b6 drop Python 2.7 and 3.4 support #494 ( 0a6bf21 ) BREAKING CHANGES \u00b6 Due to the our new policy of enterprise user support we will drop abandoned version of python and libraries we are integrated with as soon as they reach official end of life. 1.0.2 (2020-07-31) \u00b6 Bug Fixes \u00b6 deny to use same story step twice ( d379956 ) 1.0.1 (2020-06-26) \u00b6 Bug Fixes \u00b6 prevent story to call itself recursively ( 4a7007a ) 1.0.0 (2020-05-22) \u00b6 Features \u00b6 deprecate substories defined within the class ( c5d7930 ), closes #388 BREAKING CHANGES \u00b6 Substories defined in the same class do not deserve special treatment. From now they require to have different context contracts and failure protocols. They will be interpreted the same way as if they were defined in the other class. Shortcuts module have been removed. 0.15.0 (2020-04-16) \u00b6 Features \u00b6 support Django 4.0 ( f02a334 ) 0.14.0 (2020-03-21) \u00b6 Features \u00b6 support marshmallow v3 as a context contract definition ( a87c0c4 ) 0.13.0 (2020-03-14) \u00b6 Features \u00b6 use assignment expression instead of Success keyword arguments ( 9756571 ) 0.12.0 (2020-03-06) \u00b6 Features \u00b6 support coroutine functions as story step definitions ( 55cbfda ) 0.11.2 (2020-03-02) \u00b6 Bug Fixes \u00b6 hide context private attributes in closure ( f8144aa ) hide failure and success summary private attributes in closure ( eae4e95 ) hide FailureError private attributes in closure ( 1fafcc1 ) hide story private attributes in closure ( 9e79e14 ) 0.11.1 (2020-02-28) \u00b6 Bug Fixes \u00b6 deny to define stories without steps ( 5067546 ) 0.11.0 (2020-02-14) \u00b6 Features \u00b6 Add context contract to the story. Success keyword arguments can be validated by contract definition in the story. Raise MutationError when some story method tries to set or delete context attribute directly. Only keyword arguments are allowed to call and run the story. Raise StoryDefinitionError when arguments decorator is used incorrectly. migrate to pydantic v1.x ( 9049eae ) 0.10.2 (2020-02-11) \u00b6 Bug Fixes \u00b6 prevent generated changelog from style guide violation ( 7d4047d ) 0.10.1 (2019-05-31) \u00b6 Fix pytest reporter to work with fixture functions and pytest-bdd plugin properly. 0.10 (2019-02-27) \u00b6 Add failure protocol of the story. Failure argument should match protocol definition in the story. Replace multiple argument decorators with single arguments . Raise ContextContractError when keyword argument given to Success already exists in the context. Raise ContextContractError when the story can not find necessary arguments in the context. Make context an immutable object. Python 3.7 support. 0.9 (2018-11-28) \u00b6 Enforce I noun with non callable attributes in the story definition. Context is passed as an argument into story step methods. Pass real class instances into step method. Show story execution path in the Context representation. Add Sentry, Py.test and Django Debug Toolbar plugins with Context reporter built in. Raise an exception on Failure when the story was called directly. Support iterable protocol in the Context class. Add Failure reason. Fix Skip result behavior in deeper sub-story hierarchy. 0.8 (2018-05-12) \u00b6 Add dir() and repr() support to the context class. Failed result holds a link to the context. 0.7 (2018-05-06) \u00b6 Add run interface to the story. 0.6 (2018-04-19) \u00b6 Representation methods for story, context and point result classes. Python 2 support. 0.5 (2018-04-07) \u00b6 Do not execute nested stories of the skipped story. 0.4 (2018-04-07) \u00b6 Package was rewritten with linearization algorithm. Skip result was added to finish nested stories without finish the caller. 0.0.3 (2018-04-06) \u00b6 Nested stories support. 0.0.2 (2018-04-03) \u00b6 Fix class and instance attribute access. Validate return values. Make context append only. 0.0.1 (2018-04-02) \u00b6 Initial release. \u2014 \u2b50 \u2014","title":"Changelog"},{"location":"changelog/#510-2022-10-14","text":"","title":"5.1.0 (2022-10-14)"},{"location":"changelog/#features","text":"story could define its actor #696 5547ada","title":"Features"},{"location":"changelog/#500-2022-07-21","text":"","title":"5.0.0 (2022-07-21)"},{"location":"changelog/#code-refactoring","text":"earthquake #627 f2b793f","title":"Code Refactoring"},{"location":"changelog/#features_1","text":"add argument and variable placeholders #704 24ed603 declare argument including validation #605 ccc0308 declare argument without validation #602 a599aec declare variable including validation #606 670f879 declare variable without validation #591 d760230 deny to assign undeclared variable #680 b1a99aa deny to pass undeclared arguments #681 9705232 execute steps in given order #664 076c656 implement @initiate decorator #324 f747b5d implement @initiate restrictions #649 d4d24d4 propagate exceptions #631 fbb87b4 state union merge variable validators #688 cf9afc4 story call should return none #630 0622d21 story steps could assign state variable #693 0c30861","title":"Features"},{"location":"changelog/#breaking-changes","text":"The old codebase was removed. The library was redesigned from scratch. A lot of existed functionality was removed. Contrib integrations was moved to separate repositories. The goal of the library stays the same. Allow to express domain knowledge inside codebase with minimal friction. The approach we took is similar with the old one but most of design flaws was fixed in new version.","title":"BREAKING CHANGES"},{"location":"changelog/#410-2020-11-20","text":"","title":"4.1.0 (2020-11-20)"},{"location":"changelog/#features_2","text":"support pypy interpreter #42 ( 08fe88a )","title":"Features"},{"location":"changelog/#400-2020-11-12","text":"","title":"4.0.0 (2020-11-12)"},{"location":"changelog/#build-system","text":"add python 3.9 support #553 ( a48fec7 )","title":"Build System"},{"location":"changelog/#breaking-changes_1","text":"drop python 3.6 support.","title":"BREAKING CHANGES"},{"location":"changelog/#300-2020-10-01","text":"","title":"3.0.0 (2020-10-01)"},{"location":"changelog/#features_3","text":"rename Skip marker to Next marker #141 ( 5799aef )","title":"Features"},{"location":"changelog/#breaking-changes_2","text":"All usage of the Skip() marker should be replaced with Next() marker.","title":"BREAKING CHANGES"},{"location":"changelog/#200-2020-08-30","text":"","title":"2.0.0 (2020-08-30)"},{"location":"changelog/#code-refactoring_1","text":"drop Python 2.7 and 3.4 support #494 ( 0a6bf21 )","title":"Code Refactoring"},{"location":"changelog/#breaking-changes_3","text":"Due to the our new policy of enterprise user support we will drop abandoned version of python and libraries we are integrated with as soon as they reach official end of life.","title":"BREAKING CHANGES"},{"location":"changelog/#102-2020-07-31","text":"","title":"1.0.2 (2020-07-31)"},{"location":"changelog/#bug-fixes","text":"deny to use same story step twice ( d379956 )","title":"Bug Fixes"},{"location":"changelog/#101-2020-06-26","text":"","title":"1.0.1 (2020-06-26)"},{"location":"changelog/#bug-fixes_1","text":"prevent story to call itself recursively ( 4a7007a )","title":"Bug Fixes"},{"location":"changelog/#100-2020-05-22","text":"","title":"1.0.0 (2020-05-22)"},{"location":"changelog/#features_4","text":"deprecate substories defined within the class ( c5d7930 ), closes #388","title":"Features"},{"location":"changelog/#breaking-changes_4","text":"Substories defined in the same class do not deserve special treatment. From now they require to have different context contracts and failure protocols. They will be interpreted the same way as if they were defined in the other class. Shortcuts module have been removed.","title":"BREAKING CHANGES"},{"location":"changelog/#0150-2020-04-16","text":"","title":"0.15.0 (2020-04-16)"},{"location":"changelog/#features_5","text":"support Django 4.0 ( f02a334 )","title":"Features"},{"location":"changelog/#0140-2020-03-21","text":"","title":"0.14.0 (2020-03-21)"},{"location":"changelog/#features_6","text":"support marshmallow v3 as a context contract definition ( a87c0c4 )","title":"Features"},{"location":"changelog/#0130-2020-03-14","text":"","title":"0.13.0 (2020-03-14)"},{"location":"changelog/#features_7","text":"use assignment expression instead of Success keyword arguments ( 9756571 )","title":"Features"},{"location":"changelog/#0120-2020-03-06","text":"","title":"0.12.0 (2020-03-06)"},{"location":"changelog/#features_8","text":"support coroutine functions as story step definitions ( 55cbfda )","title":"Features"},{"location":"changelog/#0112-2020-03-02","text":"","title":"0.11.2 (2020-03-02)"},{"location":"changelog/#bug-fixes_2","text":"hide context private attributes in closure ( f8144aa ) hide failure and success summary private attributes in closure ( eae4e95 ) hide FailureError private attributes in closure ( 1fafcc1 ) hide story private attributes in closure ( 9e79e14 )","title":"Bug Fixes"},{"location":"changelog/#0111-2020-02-28","text":"","title":"0.11.1 (2020-02-28)"},{"location":"changelog/#bug-fixes_3","text":"deny to define stories without steps ( 5067546 )","title":"Bug Fixes"},{"location":"changelog/#0110-2020-02-14","text":"","title":"0.11.0 (2020-02-14)"},{"location":"changelog/#features_9","text":"Add context contract to the story. Success keyword arguments can be validated by contract definition in the story. Raise MutationError when some story method tries to set or delete context attribute directly. Only keyword arguments are allowed to call and run the story. Raise StoryDefinitionError when arguments decorator is used incorrectly. migrate to pydantic v1.x ( 9049eae )","title":"Features"},{"location":"changelog/#0102-2020-02-11","text":"","title":"0.10.2 (2020-02-11)"},{"location":"changelog/#bug-fixes_4","text":"prevent generated changelog from style guide violation ( 7d4047d )","title":"Bug Fixes"},{"location":"changelog/#0101-2019-05-31","text":"Fix pytest reporter to work with fixture functions and pytest-bdd plugin properly.","title":"0.10.1 (2019-05-31)"},{"location":"changelog/#010-2019-02-27","text":"Add failure protocol of the story. Failure argument should match protocol definition in the story. Replace multiple argument decorators with single arguments . Raise ContextContractError when keyword argument given to Success already exists in the context. Raise ContextContractError when the story can not find necessary arguments in the context. Make context an immutable object. Python 3.7 support.","title":"0.10 (2019-02-27)"},{"location":"changelog/#09-2018-11-28","text":"Enforce I noun with non callable attributes in the story definition. Context is passed as an argument into story step methods. Pass real class instances into step method. Show story execution path in the Context representation. Add Sentry, Py.test and Django Debug Toolbar plugins with Context reporter built in. Raise an exception on Failure when the story was called directly. Support iterable protocol in the Context class. Add Failure reason. Fix Skip result behavior in deeper sub-story hierarchy.","title":"0.9 (2018-11-28)"},{"location":"changelog/#08-2018-05-12","text":"Add dir() and repr() support to the context class. Failed result holds a link to the context.","title":"0.8 (2018-05-12)"},{"location":"changelog/#07-2018-05-06","text":"Add run interface to the story.","title":"0.7 (2018-05-06)"},{"location":"changelog/#06-2018-04-19","text":"Representation methods for story, context and point result classes. Python 2 support.","title":"0.6 (2018-04-19)"},{"location":"changelog/#05-2018-04-07","text":"Do not execute nested stories of the skipped story.","title":"0.5 (2018-04-07)"},{"location":"changelog/#04-2018-04-07","text":"Package was rewritten with linearization algorithm. Skip result was added to finish nested stories without finish the caller.","title":"0.4 (2018-04-07)"},{"location":"changelog/#003-2018-04-06","text":"Nested stories support.","title":"0.0.3 (2018-04-06)"},{"location":"changelog/#002-2018-04-03","text":"Fix class and instance attribute access. Validate return values. Make context append only.","title":"0.0.2 (2018-04-03)"},{"location":"changelog/#001-2018-04-02","text":"Initial release. \u2014 \u2b50 \u2014","title":"0.0.1 (2018-04-02)"},{"location":"initiate/","text":"@initiate \u00b6 Sometimes high-level wrapping stories consist from inner stories completely. In that case it's tedious to copy-paste steps definition into constructor arguments. To reduce level of boilerplace code in such cases, stories library provides @initiate decorator. Principles \u00b6 All story steps would be used in class constructor arguments Only Story subclasses could be initiated Initiated Story class should not have step methods Initiated Story class should not have constructor All story steps would be used in class constructor arguments \u00b6 When you decorate story class with @initiate decorator, in addition to the __call__ method it would add __init__ method as well. Story steps would be used as names for constructor arguments. @initiate >>> from stories import Story , I , initiate >>> @initiate ... class Purchase ( Story ): ... I . find_order ... I . find_customer ... I . persist_payment __init__ >>> from stories import Story , I >>> class Purchase ( Story ): ... I . find_order ... I . find_customer ... I . persist_payment ... ... def __init__ ( self , find_order , find_customer , persist_payment ): ... self . find_order = find_order ... self . find_customer = find_customer ... self . persist_payment = persist_payment Only Story subclasses could be initiated \u00b6 Classes decorated by @initiate function should be subclasess of the Story . Otherwise, there is no steps to operate on. >>> @initiate ... class Purchase : ... def find_order ( self , state ): ... state . order = self . load_order ( state . order_id ) ... ... def find_customer ( self , state ): ... state . customer = self . load_customer ( state . customer_id ) ... ... def persist_payment ( self , state ): ... self . create_payment ( state . order_id , state . customer_id ) Traceback (most recent call last): ... _stories.exceptions.StoryError : @initiate can decorate Story subclasses only Initiated Story class should not have step methods \u00b6 @initiate decorator does not allow to mix step methods with nested stories on initiated classes. Usually, story steps defined by methods expects some additional dependencies to be passed in the constructor. >>> from stories import Story , I , initiate >>> @initiate ... class Purchase ( Story ): ... I . find_order ... I . find_customer ... I . persist_payment ... ... def find_order ( self , state ): ... state . order = self . load_order ( state . order_id ) Traceback (most recent call last): ... _stories.exceptions.StoryError : Story decorated by @initiate can not have step methods Initiated Story class should not have constructor \u00b6 >>> from stories import Story , I , initiate >>> @initiate ... class Purchase ( Story ): ... I . find_order ... I . find_customer ... I . persist_payment ... ... def __init__ ( self ): ... ... Traceback (most recent call last): ... _stories.exceptions.StoryError : Story decorated by @initiate can not have constructor defined \u2014 \u2b50 \u2014","title":"Initiate"},{"location":"initiate/#initiate","text":"Sometimes high-level wrapping stories consist from inner stories completely. In that case it's tedious to copy-paste steps definition into constructor arguments. To reduce level of boilerplace code in such cases, stories library provides @initiate decorator.","title":"@initiate"},{"location":"initiate/#principles","text":"All story steps would be used in class constructor arguments Only Story subclasses could be initiated Initiated Story class should not have step methods Initiated Story class should not have constructor","title":"Principles"},{"location":"initiate/#all-story-steps-would-be-used-in-class-constructor-arguments","text":"When you decorate story class with @initiate decorator, in addition to the __call__ method it would add __init__ method as well. Story steps would be used as names for constructor arguments. @initiate >>> from stories import Story , I , initiate >>> @initiate ... class Purchase ( Story ): ... I . find_order ... I . find_customer ... I . persist_payment __init__ >>> from stories import Story , I >>> class Purchase ( Story ): ... I . find_order ... I . find_customer ... I . persist_payment ... ... def __init__ ( self , find_order , find_customer , persist_payment ): ... self . find_order = find_order ... self . find_customer = find_customer ... self . persist_payment = persist_payment","title":"All story steps would be used in class constructor arguments"},{"location":"initiate/#only-story-subclasses-could-be-initiated","text":"Classes decorated by @initiate function should be subclasess of the Story . Otherwise, there is no steps to operate on. >>> @initiate ... class Purchase : ... def find_order ( self , state ): ... state . order = self . load_order ( state . order_id ) ... ... def find_customer ( self , state ): ... state . customer = self . load_customer ( state . customer_id ) ... ... def persist_payment ( self , state ): ... self . create_payment ( state . order_id , state . customer_id ) Traceback (most recent call last): ... _stories.exceptions.StoryError : @initiate can decorate Story subclasses only","title":"Only Story subclasses could be initiated"},{"location":"initiate/#initiated-story-class-should-not-have-step-methods","text":"@initiate decorator does not allow to mix step methods with nested stories on initiated classes. Usually, story steps defined by methods expects some additional dependencies to be passed in the constructor. >>> from stories import Story , I , initiate >>> @initiate ... class Purchase ( Story ): ... I . find_order ... I . find_customer ... I . persist_payment ... ... def find_order ( self , state ): ... state . order = self . load_order ( state . order_id ) Traceback (most recent call last): ... _stories.exceptions.StoryError : Story decorated by @initiate can not have step methods","title":"Initiated Story class should not have step methods"},{"location":"initiate/#initiated-story-class-should-not-have-constructor","text":">>> from stories import Story , I , initiate >>> @initiate ... class Purchase ( Story ): ... I . find_order ... I . find_customer ... I . persist_payment ... ... def __init__ ( self ): ... ... Traceback (most recent call last): ... _stories.exceptions.StoryError : Story decorated by @initiate can not have constructor defined \u2014 \u2b50 \u2014","title":"Initiated Story class should not have constructor"},{"location":"installation/","text":"Installation \u00b6 The stories library is available on PyPI. To install it run: pip install -U stories We use semantic release to publish packages as soon as pull requests land to the release branch. It's not necessary to use develompment version of the library. We officially support three last minor releases of CPython interpreter and last minor release of PyPy interpreter. We highly recommend the latest patch release of each Python series. \u2014 \u2b50 \u2014","title":"Installation"},{"location":"installation/#installation","text":"The stories library is available on PyPI. To install it run: pip install -U stories We use semantic release to publish packages as soon as pull requests land to the release branch. It's not necessary to use develompment version of the library. We officially support three last minor releases of CPython interpreter and last minor release of PyPy interpreter. We highly recommend the latest patch release of each Python series. \u2014 \u2b50 \u2014","title":"Installation"},{"location":"state/","text":"State \u00b6 It's hard to figure out what variables could be set by story. Or what arguments it does expect as input. It is possible to make this state contract explicit. You could inherit from State class and define allowed variables and arguments on it. Principles \u00b6 Variable allow attribute assignment Argument allow constructor usage Only declared variables could be assigned Only declared arguments could be passed Attribute assignment validates variable value Constructor argument validates passed value Validation errors are propagated as usual errors Validation errors would be raised by constructor Validation could normalize value State union joins all defined variables State union joins all variable validators Variable allow attribute assignment \u00b6 Classes inherited from State could reduce set of variables which allowed to be defined by attribute assignment. If you declare variable on the state class, it could be assignment once inside step method. sync >>> from dataclasses import dataclass >>> from typing import Callable >>> from stories import Story , I , State , Variable >>> from app.repositories import load_order , load_customer , create_payment >>> @dataclass ... class Purchase ( Story ): ... I . find_order ... I . find_customer ... I . check_balance ... I . persist_payment ... ... def find_order ( self , state ): ... state . order = self . load_order ( order_id = 1 ) ... ... def find_customer ( self , state ): ... state . customer = self . load_customer ( customer_id = 1 ) ... ... def check_balance ( self , state ): ... if not state . order . affordable_for ( state . customer ): ... raise Exception ... ... def persist_payment ( self , state ): ... state . payment = self . create_payment ( order_id = 1 , customer_id = 1 ) ... ... load_order : Callable ... load_customer : Callable ... create_payment : Callable >>> class PurchaseState ( State ): ... order = Variable () ... customer = Variable () ... payment = Variable () >>> purchase = Purchase ( ... load_order = load_order , ... load_customer = load_customer , ... create_payment = create_payment , ... ) >>> state = PurchaseState () >>> purchase ( state ) >>> state . payment Payment(due_date=datetime.datetime(1999, 12, 31, 0, 0)) async >>> import asyncio >>> from dataclasses import dataclass >>> from typing import Coroutine >>> from stories import Story , I , State , Variable >>> from aioapp.repositories import load_order , load_customer , create_payment >>> @dataclass ... class Purchase ( Story ): ... I . find_order ... I . find_customer ... I . check_balance ... I . persist_payment ... ... async def find_order ( self , state ): ... state . order = await self . load_order ( order_id = 1 ) ... ... async def find_customer ( self , state ): ... state . customer = await self . load_customer ( customer_id = 1 ) ... ... async def check_balance ( self , state ): ... if not state . order . affordable_for ( state . customer ): ... raise Exception ... ... async def persist_payment ( self , state ): ... state . payment = await self . create_payment ( ... order_id = 1 , customer_id = 1 ... ) ... ... load_order : Coroutine ... load_customer : Coroutine ... create_payment : Coroutine >>> class PurchaseState ( State ): ... order = Variable () ... customer = Variable () ... payment = Variable () >>> purchase = Purchase ( ... load_order = load_order , ... load_customer = load_customer , ... create_payment = create_payment , ... ) >>> state = PurchaseState () >>> asyncio . run ( purchase ( state )) >>> state . payment Payment(due_date=datetime.datetime(1999, 12, 31, 0, 0)) Argument allow constructor usage \u00b6 Argument declaration is superset of the Variable declaration. All rules applied to Variable applies to Argument as well. For example, variable declared as Argument is allowed to be assigned as attribute by one of the story step. However, Argument declaration allows variable with that name to be passed to the state constructor before story execution would even starts. sync >>> from dataclasses import dataclass >>> from typing import Callable >>> from stories import Story , I , State , Argument , Variable >>> from app.repositories import load_order , load_customer , create_payment >>> @dataclass ... class Purchase ( Story ): ... I . find_order ... I . find_customer ... I . check_balance ... I . persist_payment ... ... def find_order ( self , state ): ... state . order = self . load_order ( state . order_id ) ... ... def find_customer ( self , state ): ... state . customer = self . load_customer ( state . customer_id ) ... ... def check_balance ( self , state ): ... if not state . order . affordable_for ( state . customer ): ... raise Exception ... ... def persist_payment ( self , state ): ... state . payment = self . create_payment ( ... order_id = state . order_id , customer_id = state . customer_id ... ) ... ... load_order : Callable ... load_customer : Callable ... create_payment : Callable >>> class PurchaseState ( State ): ... order_id = Argument () ... customer_id = Argument () ... order = Variable () ... customer = Variable () ... payment = Variable () >>> purchase = Purchase ( ... load_order = load_order , ... load_customer = load_customer , ... create_payment = create_payment , ... ) >>> state = PurchaseState ( order_id = 1 , customer_id = 1 ) >>> purchase ( state ) >>> state . payment Payment(due_date=datetime.datetime(1999, 12, 31, 0, 0)) async >>> import asyncio >>> from dataclasses import dataclass >>> from typing import Coroutine >>> from stories import Story , I , State , Argument , Variable >>> from aioapp.repositories import load_order , load_customer , create_payment >>> @dataclass ... class Purchase ( Story ): ... I . find_order ... I . find_customer ... I . check_balance ... I . persist_payment ... ... async def find_order ( self , state ): ... state . order = await self . load_order ( state . order_id ) ... ... async def find_customer ( self , state ): ... state . customer = await self . load_customer ( state . customer_id ) ... ... async def check_balance ( self , state ): ... if not state . order . affordable_for ( state . customer ): ... raise Exception ... ... async def persist_payment ( self , state ): ... state . payment = await self . create_payment ( ... order_id = state . order_id , customer_id = state . customer_id ... ) ... ... load_order : Coroutine ... load_customer : Coroutine ... create_payment : Coroutine >>> class PurchaseState ( State ): ... order_id = Argument () ... customer_id = Argument () ... order = Variable () ... customer = Variable () ... payment = Variable () >>> purchase = Purchase ( ... load_order = load_order , ... load_customer = load_customer , ... create_payment = create_payment , ... ) >>> state = PurchaseState ( order_id = 1 , customer_id = 1 ) >>> asyncio . run ( purchase ( state )) >>> state . payment Payment(due_date=datetime.datetime(1999, 12, 31, 0, 0)) Only declared variables could be assigned \u00b6 Variables with random names allowed to be assigned only if you would use plain State object. If you declare variables using inheritance from State class, only declared variables would be allowed to be assigned later by steps. If you try to assing unknown variable, an error would be raised. sync >>> from dataclasses import dataclass >>> from typing import Callable >>> from stories import Story , I , State , Variable >>> from app.repositories import load_order >>> @dataclass ... class Purchase ( Story ): ... I . find_order ... ... def find_order ( self , state ): ... state . order = self . load_order ( order_id = 1 ) ... ... load_order : Callable >>> class PurchaseState ( State ): ... customer = Variable () >>> purchase = Purchase ( load_order = load_order ) >>> state = PurchaseState () >>> purchase ( state ) Traceback (most recent call last): ... _stories.exceptions.StateError : Unknown variable assignment: order <BLANKLINE> PurchaseState async >>> import asyncio >>> from dataclasses import dataclass >>> from typing import Coroutine >>> from stories import Story , I , State , Variable >>> from aioapp.repositories import load_order >>> @dataclass ... class Purchase ( Story ): ... I . find_order ... ... async def find_order ( self , state ): ... state . order = await self . load_order ( order_id = 1 ) ... ... load_order : Coroutine >>> class PurchaseState ( State ): ... customer = Variable () >>> purchase = Purchase ( load_order = load_order ) >>> state = PurchaseState () >>> asyncio . run ( purchase ( state )) Traceback (most recent call last): ... _stories.exceptions.StateError : Unknown variable assignment: order <BLANKLINE> PurchaseState Only declared arguments could be passed \u00b6 If you try to pass an argument to the state class which was not declared using Argument , error would be thrown immediately. Even if you declare state attribute using Variable it will not be allowed to be used as state constructor argument. sync >>> from dataclasses import dataclass >>> from typing import Callable >>> from stories import Story , I , State , Argument , Variable >>> from app.repositories import load_order >>> @dataclass ... class Purchase ( Story ): ... I . find_order ... ... def find_order ( self , state ): ... state . order = self . load_order ( state . order_id ) ... ... load_order : Callable >>> class PurchaseState ( State ): ... order_id = Argument () ... order = Variable () >>> purchase = Purchase ( load_order = load_order ) >>> PurchaseState ( customer_id = 1 ) Traceback (most recent call last): ... _stories.exceptions.StateError : Unknown argument passed: customer_id <BLANKLINE> PurchaseState async >>> import asyncio >>> from dataclasses import dataclass >>> from typing import Coroutine >>> from stories import Story , I , State , Argument , Variable >>> from aioapp.repositories import load_order >>> @dataclass ... class Purchase ( Story ): ... I . find_order ... ... async def find_order ( self , state ): ... state . order = await self . load_order ( state . order_id ) ... ... load_order : Coroutine >>> class PurchaseState ( State ): ... order_id = Argument () ... order = Variable () >>> purchase = Purchase ( load_order = load_order ) >>> PurchaseState ( customer_id = 1 ) Traceback (most recent call last): ... _stories.exceptions.StateError : Unknown argument passed: customer_id <BLANKLINE> PurchaseState Attribute assignment validates variable value \u00b6 When story step assign attributes to the state, validator passed to the Variable would be applied to the value. Validator is a function of single argument. It should return attribute value or raise exception if value is wrong. If validator returns a value, it will be assigned to the state attribute. sync >>> from dataclasses import dataclass >>> from typing import Callable >>> from stories import Story , I , State , Variable >>> from app.repositories import load_order >>> from app.entities import Order >>> def is_order ( value ): ... if isinstance ( value , Order ): ... return value ... else : ... raise Exception ( f \" { value !r} is not valid order\" ) >>> @dataclass ... class Purchase ( Story ): ... I . find_order ... ... def find_order ( self , state ): ... state . order = self . load_order ( order_id = 1 ) ... ... load_order : Callable >>> class PurchaseState ( State ): ... order = Variable ( is_order ) >>> purchase = Purchase ( load_order = load_order ) >>> state = PurchaseState () >>> purchase ( state ) >>> state . order Order(product=Product(name='Books'), cost=Cost(at=datetime.datetime(1999, 12, 31, 0, 0), amount=7)) async >>> import asyncio >>> from dataclasses import dataclass >>> from typing import Coroutine >>> from stories import Story , I , State , Variable >>> from aioapp.repositories import load_order >>> from aioapp.entities import Order >>> def is_order ( value ): ... if isinstance ( value , Order ): ... return value ... else : ... raise Exception ( f ' { value !r} is not valid order' ) >>> @dataclass ... class Purchase ( Story ): ... I . find_order ... ... async def find_order ( self , state ): ... state . order = await self . load_order ( order_id = 1 ) ... ... load_order : Coroutine >>> class PurchaseState ( State ): ... order = Variable ( is_order ) >>> purchase = Purchase ( load_order = load_order ) >>> state = PurchaseState () >>> asyncio . run ( purchase ( state )) >>> state . order Order(product=Product(name='Books'), cost=Cost(at=datetime.datetime(1999, 12, 31, 0, 0), amount=7)) Constructor argument validates passed value \u00b6 When pass arguments to the state constructor, validator passed to the Argument would be applied to the value. Validator is a function of single argument. It should return argument value or raise exception if value is wrong. If validator returns a value, it will be assigned to the state attribute. sync >>> from dataclasses import dataclass >>> from typing import Callable >>> from stories import Story , I , State , Argument >>> from app.repositories import load_order >>> from app.entities import Order >>> def is_order_id ( value ): ... if isinstance ( value , int ): ... return value ... else : ... raise Exception ( f \" { value !r} is not valid order id\" ) >>> def is_order ( value ): ... if isinstance ( value , Order ): ... return value ... else : ... raise Exception ( f \" { value !r} is not valid order\" ) >>> @dataclass ... class Purchase ( Story ): ... I . find_order ... ... def find_order ( self , state ): ... state . order = self . load_order ( state . order_id ) ... ... load_order : Callable >>> class PurchaseState ( State ): ... order_id = Argument ( is_order_id ) ... order = Variable ( is_order ) >>> purchase = Purchase ( load_order = load_order ) >>> state = PurchaseState ( order_id = 1 ) >>> purchase ( state ) >>> state . order_id 1 async >>> import asyncio >>> from dataclasses import dataclass >>> from typing import Coroutine >>> from stories import Story , I , State , Argument >>> from aioapp.repositories import load_order >>> from aioapp.entities import Order >>> def is_order_id ( value ): ... if isinstance ( value , int ): ... return value ... else : ... raise Exception ( f ' { value !r} is not valid order id' ) >>> def is_order ( value ): ... if isinstance ( value , Order ): ... return value ... else : ... raise Exception ( f ' { value !r} is not valid order' ) >>> @dataclass ... class Purchase ( Story ): ... I . find_order ... ... async def find_order ( self , state ): ... state . order = await self . load_order ( state . order_id ) ... ... load_order : Coroutine >>> class PurchaseState ( State ): ... order_id = Argument ( is_order_id ) ... order = Variable ( is_order ) >>> purchase = Purchase ( load_order = load_order ) >>> state = PurchaseState ( order_id = 1 ) >>> asyncio . run ( purchase ( state )) >>> state . order_id 1 Validation errors are propagated as usual errors \u00b6 If validation function raises exception, story execution would stops. It would be propagated as usual exception which could happend inside the step. sync >>> from dataclasses import dataclass >>> from typing import Callable >>> from stories import Story , I , State , Variable >>> @dataclass ... class Purchase ( Story ): ... I . find_order ... ... def find_order ( self , state ): ... state . order = self . load_order ( order_id = 1 ) ... ... load_order : Callable >>> class PurchaseState ( State ): ... order = Variable ( is_order ) >>> purchase = Purchase ( load_order = lambda order_id : None ) >>> state = PurchaseState () >>> purchase ( state ) Traceback (most recent call last): ... Exception : None is not valid order async >>> import asyncio >>> from dataclasses import dataclass >>> from typing import Coroutine >>> from stories import Story , I , State , Variable >>> @dataclass ... class Purchase ( Story ): ... I . find_order ... ... async def find_order ( self , state ): ... state . order = await self . load_order ( order_id = 1 ) ... ... load_order : Coroutine >>> class PurchaseState ( State ): ... order = Variable ( is_order ) >>> async def load_order ( order_id ): ... pass >>> purchase = Purchase ( load_order = load_order ) >>> state = PurchaseState () >>> asyncio . run ( purchase ( state )) Traceback (most recent call last): ... Exception : None is not valid order Validation errors would be raised by constructor \u00b6 If validation funcution raises exception, state constructor would propagate this error. sync >>> from dataclasses import dataclass >>> from typing import Callable >>> from stories import Story , I , State , Argument >>> from app.repositories import load_order >>> def is_order_id ( value ): ... if isinstance ( value , int ): ... return value ... else : ... raise Exception ( f \" { value !r} is not valid order id\" ) >>> @dataclass ... class Purchase ( Story ): ... I . find_order ... ... def find_order ( self , state ): ... state . order = self . load_order ( state . order_id ) ... ... load_order : Callable >>> class PurchaseState ( State ): ... order_id = Argument ( is_order_id ) >>> purchase = Purchase ( load_order = load_order ) >>> PurchaseState ( order_id = '1' ) Traceback (most recent call last): ... Exception : '1' is not valid order id async >>> from dataclasses import dataclass >>> from typing import Coroutine >>> from stories import Story , I , State , Argument >>> from aioapp.repositories import load_order >>> def is_order_id ( value ): ... if isinstance ( value , int ): ... return value ... else : ... raise Exception ( f ' { value !r} is not valid order id' ) >>> @dataclass ... class Purchase ( Story ): ... I . find_order ... ... async def find_order ( self , state ): ... state . order = await self . load_order ( state . order_id ) ... ... load_order : Coroutine >>> class PurchaseState ( State ): ... order_id = Argument ( is_order_id ) >>> purchase = Purchase ( load_order = load_order ) >>> PurchaseState ( order_id = '1' ) Traceback (most recent call last): ... Exception : '1' is not valid order id Validation could normalize value \u00b6 Validator function could cast value passed to it to the new type. It's a similar process to normalization common to API schema libraries. To convert passed value to something new, just return new thing. New value returned by validator function would be assigned to the state attribute. This works both for Variable and Argument validators. sync >>> from dataclasses import dataclass >>> from typing import Callable >>> from stories import Story , I , State >>> from app.entities import Customer >>> def is_customer ( value ): ... if isinstance ( value , dict ) and value . keys () == { 'balance' } and isinstance ( value [ 'balance' ], int ): ... return Customer ( value [ 'balance' ]) ... else : ... raise Exception ( f ' { value !r} is not valid customer' ) >>> @dataclass ... class Purchase ( Story ): ... I . find_customer ... ... def find_customer ( self , state ): ... state . customer = self . load_customer ( customer_id = 1 ) ... ... load_customer : Callable >>> class PurchaseState ( State ): ... customer = Variable ( is_customer ) >>> def load_customer ( customer_id ): ... return { 'balance' : 100 } >>> purchase = Purchase ( load_customer = load_customer ) >>> state = PurchaseState () >>> purchase ( state ) >>> state . customer Customer(balance=100) async >>> import asyncio >>> from dataclasses import dataclass >>> from typing import Coroutine >>> from stories import Story , I , State , Variable >>> from app.entities import Customer >>> def is_customer ( value ): ... if isinstance ( value , dict ) and value . keys () == { 'balance' } and isinstance ( value [ 'balance' ], int ): ... return Customer ( value [ 'balance' ]) ... else : ... raise Exception ( f ' { value !r} is not valid customer' ) >>> @dataclass ... class Purchase ( Story ): ... I . find_customer ... ... async def find_customer ( self , state ): ... state . customer = await self . load_customer ( customer_id = 1 ) ... ... load_customer : Coroutine >>> class PurchaseState ( State ): ... customer = Variable ( is_customer ) >>> async def load_customer ( customer_id ): ... return { 'balance' : 100 } >>> purchase = Purchase ( load_customer = load_customer ) >>> state = PurchaseState () >>> asyncio . run ( purchase ( state )) >>> state . customer Customer(balance=100) State union joins all defined variables \u00b6 Story composition requires complicated state object which would define variables necessary for both stories. If you defined separate state classes for both stories, you could join variables with State union operation. State union would include all variables defined in separate State classes. sync >>> from dataclasses import dataclass >>> from typing import Callable >>> from stories import Story , I , State , Variable , Union >>> from app.repositories import load_order , load_customer , create_payment >>> from app.entities import Order , Customer , Payment >>> def is_order ( value ): ... assert isinstance ( value , Order ) ... return value >>> def is_customer ( value ): ... assert isinstance ( value , Customer ) ... return value >>> def is_payment ( value ): ... assert isinstance ( value , Payment ) ... return value >>> @dataclass ... class Purchase ( Story ): ... I . find_order ... I . find_customer ... I . pay ... ... def find_order ( self , state ): ... state . order = self . load_order ( order_id = 1 ) ... ... def find_customer ( self , state ): ... state . customer = self . load_customer ( customer_id = 1 ) ... ... load_order : Callable ... load_customer : Callable ... pay : Story >>> @dataclass ... class Pay ( Story ): ... I . persist_payment ... ... def persist_payment ( self , state ): ... state . payment = self . create_payment ( ... order_id = 1 , customer_id = 1 ... ) ... ... create_payment : Callable >>> class PurchaseState ( State ): ... order = Variable ( is_order ) ... customer = Variable ( is_customer ) >>> class PayState ( State ): ... payment = Variable ( is_payment ) >>> pay = Pay ( create_payment = create_payment ) >>> purchase = Purchase ( ... load_order = load_order , ... load_customer = load_customer , ... pay = pay , ... ) >>> state_class = Union ( PurchaseState , PayState ) >>> state = state_class () >>> purchase ( state ) >>> state . payment Payment(due_date=datetime.datetime(1999, 12, 31, 0, 0)) async >>> import asyncio >>> from dataclasses import dataclass >>> from typing import Coroutine >>> from stories import Story , I , State , Variable , Union >>> from aioapp.repositories import load_order , load_customer , create_payment >>> from aioapp.entities import Order , Customer , Payment >>> def is_order ( value ): ... assert isinstance ( value , Order ) ... return value >>> def is_customer ( value ): ... assert isinstance ( value , Customer ) ... return value >>> def is_payment ( value ): ... assert isinstance ( value , Payment ) ... return value >>> @dataclass ... class Purchase ( Story ): ... I . find_order ... I . find_customer ... I . pay ... ... async def find_order ( self , state ): ... state . order = await self . load_order ( order_id = 1 ) ... ... async def find_customer ( self , state ): ... state . customer = await self . load_customer ( customer_id = 1 ) ... ... load_order : Callable ... load_customer : Callable ... pay : Story >>> @dataclass ... class Pay ( Story ): ... I . persist_payment ... ... async def persist_payment ( self , state ): ... state . payment = await self . create_payment ( ... order_id = 1 , customer_id = 1 ... ) ... ... create_payment : Callable >>> class PurchaseState ( State ): ... order = Variable ( is_order ) ... customer = Variable ( is_customer ) >>> class PayState ( State ): ... payment = Variable ( is_payment ) >>> pay = Pay ( create_payment = create_payment ) >>> purchase = Purchase ( ... load_order = load_order , ... load_customer = load_customer , ... pay = pay , ... ) >>> state_class = Union ( PurchaseState , PayState ) >>> state = state_class () >>> asyncio . run ( purchase ( state )) >>> state . payment Payment(due_date=datetime.datetime(1999, 12, 31, 0, 0)) State union joins all variable validators \u00b6 Sometimes you would define variable with the same name in different state classes. Usually, these variables would have different validation functions. Since different stories has different requirements for them. When you create a composition of these stories, you expect all requirements to the variable would be satisfied. State union would call all validators of the variable at the moment of it assignment. If at least one validator fails, execution of the story stops on that error. sync >>> from dataclasses import dataclass >>> from datetime import datetime >>> from typing import Callable >>> from stories import Story , I , State , Variable , Union >>> from app.repositories import load_order , load_customer , create_payment >>> from app.entities import Order , Customer , Payment >>> def is_low_price ( order ): ... assert order . cost . amount < 500 ... return order >>> def is_recent_price ( order ): ... assert order . cost . at >= datetime ( 1999 , 1 , 1 ) ... return order >>> @dataclass ... class Purchase ( Story ): ... I . find_order ... I . find_customer ... I . pay ... ... def find_order ( self , state ): ... state . order = self . load_order ( order_id = 1 ) ... ... def find_customer ( self , state ): ... state . customer = self . load_customer ( customer_id = 1 ) ... ... load_order : Callable ... load_customer : Callable ... pay : Story >>> @dataclass ... class Pay ( Story ): ... I . persist_payment ... ... def persist_payment ( self , state ): ... state . payment = self . create_payment ( ... order_id = 1 , customer_id = 1 ... ) ... ... create_payment : Callable >>> class PurchaseState ( State ): ... order = Variable ( is_low_price ) ... customer = Variable () >>> class PayState ( State ): ... order = Variable ( is_recent_price ) ... payment = Variable () >>> pay = Pay ( create_payment = create_payment ) >>> purchase = Purchase ( ... load_order = load_order , ... load_customer = load_customer , ... pay = pay , ... ) >>> state_class = Union ( PurchaseState , PayState ) >>> state = state_class () >>> purchase ( state ) >>> state . order . cost Cost(at=datetime.datetime(1999, 12, 31, 0, 0), amount=7) async >>> import asyncio >>> from dataclasses import dataclass >>> from datetime import datetime >>> from typing import Coroutine >>> from stories import Story , I , State , Variable , Union >>> from aioapp.repositories import load_order , load_customer , create_payment >>> from aioapp.entities import Order , Customer , Payment >>> def is_low_price ( order ): ... assert order . cost . amount < 500 ... return order >>> def is_recent_price ( order ): ... assert order . cost . at >= datetime ( 1999 , 1 , 1 ) ... return order >>> @dataclass ... class Purchase ( Story ): ... I . find_order ... I . find_customer ... I . pay ... ... async def find_order ( self , state ): ... state . order = await self . load_order ( order_id = 1 ) ... ... async def find_customer ( self , state ): ... state . customer = await self . load_customer ( customer_id = 1 ) ... ... load_order : Callable ... load_customer : Callable ... pay : Story >>> @dataclass ... class Pay ( Story ): ... I . persist_payment ... ... async def persist_payment ( self , state ): ... state . payment = await self . create_payment ( ... order_id = 1 , customer_id = 1 ... ) ... ... create_payment : Callable >>> class PurchaseState ( State ): ... order = Variable ( is_low_price ) ... customer = Variable () >>> class PayState ( State ): ... order = Variable ( is_recent_price ) ... payment = Variable () >>> pay = Pay ( create_payment = create_payment ) >>> purchase = Purchase ( ... load_order = load_order , ... load_customer = load_customer , ... pay = pay , ... ) >>> state_class = Union ( PurchaseState , PayState ) >>> state = state_class () >>> asyncio . run ( purchase ( state )) >>> state . order . cost Cost(at=datetime.datetime(1999, 12, 31, 0, 0), amount=7) \u2014 \u2b50 \u2014","title":"State"},{"location":"state/#state","text":"It's hard to figure out what variables could be set by story. Or what arguments it does expect as input. It is possible to make this state contract explicit. You could inherit from State class and define allowed variables and arguments on it.","title":"State"},{"location":"state/#principles","text":"Variable allow attribute assignment Argument allow constructor usage Only declared variables could be assigned Only declared arguments could be passed Attribute assignment validates variable value Constructor argument validates passed value Validation errors are propagated as usual errors Validation errors would be raised by constructor Validation could normalize value State union joins all defined variables State union joins all variable validators","title":"Principles"},{"location":"state/#variable-allow-attribute-assignment","text":"Classes inherited from State could reduce set of variables which allowed to be defined by attribute assignment. If you declare variable on the state class, it could be assignment once inside step method. sync >>> from dataclasses import dataclass >>> from typing import Callable >>> from stories import Story , I , State , Variable >>> from app.repositories import load_order , load_customer , create_payment >>> @dataclass ... class Purchase ( Story ): ... I . find_order ... I . find_customer ... I . check_balance ... I . persist_payment ... ... def find_order ( self , state ): ... state . order = self . load_order ( order_id = 1 ) ... ... def find_customer ( self , state ): ... state . customer = self . load_customer ( customer_id = 1 ) ... ... def check_balance ( self , state ): ... if not state . order . affordable_for ( state . customer ): ... raise Exception ... ... def persist_payment ( self , state ): ... state . payment = self . create_payment ( order_id = 1 , customer_id = 1 ) ... ... load_order : Callable ... load_customer : Callable ... create_payment : Callable >>> class PurchaseState ( State ): ... order = Variable () ... customer = Variable () ... payment = Variable () >>> purchase = Purchase ( ... load_order = load_order , ... load_customer = load_customer , ... create_payment = create_payment , ... ) >>> state = PurchaseState () >>> purchase ( state ) >>> state . payment Payment(due_date=datetime.datetime(1999, 12, 31, 0, 0)) async >>> import asyncio >>> from dataclasses import dataclass >>> from typing import Coroutine >>> from stories import Story , I , State , Variable >>> from aioapp.repositories import load_order , load_customer , create_payment >>> @dataclass ... class Purchase ( Story ): ... I . find_order ... I . find_customer ... I . check_balance ... I . persist_payment ... ... async def find_order ( self , state ): ... state . order = await self . load_order ( order_id = 1 ) ... ... async def find_customer ( self , state ): ... state . customer = await self . load_customer ( customer_id = 1 ) ... ... async def check_balance ( self , state ): ... if not state . order . affordable_for ( state . customer ): ... raise Exception ... ... async def persist_payment ( self , state ): ... state . payment = await self . create_payment ( ... order_id = 1 , customer_id = 1 ... ) ... ... load_order : Coroutine ... load_customer : Coroutine ... create_payment : Coroutine >>> class PurchaseState ( State ): ... order = Variable () ... customer = Variable () ... payment = Variable () >>> purchase = Purchase ( ... load_order = load_order , ... load_customer = load_customer , ... create_payment = create_payment , ... ) >>> state = PurchaseState () >>> asyncio . run ( purchase ( state )) >>> state . payment Payment(due_date=datetime.datetime(1999, 12, 31, 0, 0))","title":"Variable allow attribute assignment"},{"location":"state/#argument-allow-constructor-usage","text":"Argument declaration is superset of the Variable declaration. All rules applied to Variable applies to Argument as well. For example, variable declared as Argument is allowed to be assigned as attribute by one of the story step. However, Argument declaration allows variable with that name to be passed to the state constructor before story execution would even starts. sync >>> from dataclasses import dataclass >>> from typing import Callable >>> from stories import Story , I , State , Argument , Variable >>> from app.repositories import load_order , load_customer , create_payment >>> @dataclass ... class Purchase ( Story ): ... I . find_order ... I . find_customer ... I . check_balance ... I . persist_payment ... ... def find_order ( self , state ): ... state . order = self . load_order ( state . order_id ) ... ... def find_customer ( self , state ): ... state . customer = self . load_customer ( state . customer_id ) ... ... def check_balance ( self , state ): ... if not state . order . affordable_for ( state . customer ): ... raise Exception ... ... def persist_payment ( self , state ): ... state . payment = self . create_payment ( ... order_id = state . order_id , customer_id = state . customer_id ... ) ... ... load_order : Callable ... load_customer : Callable ... create_payment : Callable >>> class PurchaseState ( State ): ... order_id = Argument () ... customer_id = Argument () ... order = Variable () ... customer = Variable () ... payment = Variable () >>> purchase = Purchase ( ... load_order = load_order , ... load_customer = load_customer , ... create_payment = create_payment , ... ) >>> state = PurchaseState ( order_id = 1 , customer_id = 1 ) >>> purchase ( state ) >>> state . payment Payment(due_date=datetime.datetime(1999, 12, 31, 0, 0)) async >>> import asyncio >>> from dataclasses import dataclass >>> from typing import Coroutine >>> from stories import Story , I , State , Argument , Variable >>> from aioapp.repositories import load_order , load_customer , create_payment >>> @dataclass ... class Purchase ( Story ): ... I . find_order ... I . find_customer ... I . check_balance ... I . persist_payment ... ... async def find_order ( self , state ): ... state . order = await self . load_order ( state . order_id ) ... ... async def find_customer ( self , state ): ... state . customer = await self . load_customer ( state . customer_id ) ... ... async def check_balance ( self , state ): ... if not state . order . affordable_for ( state . customer ): ... raise Exception ... ... async def persist_payment ( self , state ): ... state . payment = await self . create_payment ( ... order_id = state . order_id , customer_id = state . customer_id ... ) ... ... load_order : Coroutine ... load_customer : Coroutine ... create_payment : Coroutine >>> class PurchaseState ( State ): ... order_id = Argument () ... customer_id = Argument () ... order = Variable () ... customer = Variable () ... payment = Variable () >>> purchase = Purchase ( ... load_order = load_order , ... load_customer = load_customer , ... create_payment = create_payment , ... ) >>> state = PurchaseState ( order_id = 1 , customer_id = 1 ) >>> asyncio . run ( purchase ( state )) >>> state . payment Payment(due_date=datetime.datetime(1999, 12, 31, 0, 0))","title":"Argument allow constructor usage"},{"location":"state/#only-declared-variables-could-be-assigned","text":"Variables with random names allowed to be assigned only if you would use plain State object. If you declare variables using inheritance from State class, only declared variables would be allowed to be assigned later by steps. If you try to assing unknown variable, an error would be raised. sync >>> from dataclasses import dataclass >>> from typing import Callable >>> from stories import Story , I , State , Variable >>> from app.repositories import load_order >>> @dataclass ... class Purchase ( Story ): ... I . find_order ... ... def find_order ( self , state ): ... state . order = self . load_order ( order_id = 1 ) ... ... load_order : Callable >>> class PurchaseState ( State ): ... customer = Variable () >>> purchase = Purchase ( load_order = load_order ) >>> state = PurchaseState () >>> purchase ( state ) Traceback (most recent call last): ... _stories.exceptions.StateError : Unknown variable assignment: order <BLANKLINE> PurchaseState async >>> import asyncio >>> from dataclasses import dataclass >>> from typing import Coroutine >>> from stories import Story , I , State , Variable >>> from aioapp.repositories import load_order >>> @dataclass ... class Purchase ( Story ): ... I . find_order ... ... async def find_order ( self , state ): ... state . order = await self . load_order ( order_id = 1 ) ... ... load_order : Coroutine >>> class PurchaseState ( State ): ... customer = Variable () >>> purchase = Purchase ( load_order = load_order ) >>> state = PurchaseState () >>> asyncio . run ( purchase ( state )) Traceback (most recent call last): ... _stories.exceptions.StateError : Unknown variable assignment: order <BLANKLINE> PurchaseState","title":"Only declared variables could be assigned"},{"location":"state/#only-declared-arguments-could-be-passed","text":"If you try to pass an argument to the state class which was not declared using Argument , error would be thrown immediately. Even if you declare state attribute using Variable it will not be allowed to be used as state constructor argument. sync >>> from dataclasses import dataclass >>> from typing import Callable >>> from stories import Story , I , State , Argument , Variable >>> from app.repositories import load_order >>> @dataclass ... class Purchase ( Story ): ... I . find_order ... ... def find_order ( self , state ): ... state . order = self . load_order ( state . order_id ) ... ... load_order : Callable >>> class PurchaseState ( State ): ... order_id = Argument () ... order = Variable () >>> purchase = Purchase ( load_order = load_order ) >>> PurchaseState ( customer_id = 1 ) Traceback (most recent call last): ... _stories.exceptions.StateError : Unknown argument passed: customer_id <BLANKLINE> PurchaseState async >>> import asyncio >>> from dataclasses import dataclass >>> from typing import Coroutine >>> from stories import Story , I , State , Argument , Variable >>> from aioapp.repositories import load_order >>> @dataclass ... class Purchase ( Story ): ... I . find_order ... ... async def find_order ( self , state ): ... state . order = await self . load_order ( state . order_id ) ... ... load_order : Coroutine >>> class PurchaseState ( State ): ... order_id = Argument () ... order = Variable () >>> purchase = Purchase ( load_order = load_order ) >>> PurchaseState ( customer_id = 1 ) Traceback (most recent call last): ... _stories.exceptions.StateError : Unknown argument passed: customer_id <BLANKLINE> PurchaseState","title":"Only declared arguments could be passed"},{"location":"state/#attribute-assignment-validates-variable-value","text":"When story step assign attributes to the state, validator passed to the Variable would be applied to the value. Validator is a function of single argument. It should return attribute value or raise exception if value is wrong. If validator returns a value, it will be assigned to the state attribute. sync >>> from dataclasses import dataclass >>> from typing import Callable >>> from stories import Story , I , State , Variable >>> from app.repositories import load_order >>> from app.entities import Order >>> def is_order ( value ): ... if isinstance ( value , Order ): ... return value ... else : ... raise Exception ( f \" { value !r} is not valid order\" ) >>> @dataclass ... class Purchase ( Story ): ... I . find_order ... ... def find_order ( self , state ): ... state . order = self . load_order ( order_id = 1 ) ... ... load_order : Callable >>> class PurchaseState ( State ): ... order = Variable ( is_order ) >>> purchase = Purchase ( load_order = load_order ) >>> state = PurchaseState () >>> purchase ( state ) >>> state . order Order(product=Product(name='Books'), cost=Cost(at=datetime.datetime(1999, 12, 31, 0, 0), amount=7)) async >>> import asyncio >>> from dataclasses import dataclass >>> from typing import Coroutine >>> from stories import Story , I , State , Variable >>> from aioapp.repositories import load_order >>> from aioapp.entities import Order >>> def is_order ( value ): ... if isinstance ( value , Order ): ... return value ... else : ... raise Exception ( f ' { value !r} is not valid order' ) >>> @dataclass ... class Purchase ( Story ): ... I . find_order ... ... async def find_order ( self , state ): ... state . order = await self . load_order ( order_id = 1 ) ... ... load_order : Coroutine >>> class PurchaseState ( State ): ... order = Variable ( is_order ) >>> purchase = Purchase ( load_order = load_order ) >>> state = PurchaseState () >>> asyncio . run ( purchase ( state )) >>> state . order Order(product=Product(name='Books'), cost=Cost(at=datetime.datetime(1999, 12, 31, 0, 0), amount=7))","title":"Attribute assignment validates variable value"},{"location":"state/#constructor-argument-validates-passed-value","text":"When pass arguments to the state constructor, validator passed to the Argument would be applied to the value. Validator is a function of single argument. It should return argument value or raise exception if value is wrong. If validator returns a value, it will be assigned to the state attribute. sync >>> from dataclasses import dataclass >>> from typing import Callable >>> from stories import Story , I , State , Argument >>> from app.repositories import load_order >>> from app.entities import Order >>> def is_order_id ( value ): ... if isinstance ( value , int ): ... return value ... else : ... raise Exception ( f \" { value !r} is not valid order id\" ) >>> def is_order ( value ): ... if isinstance ( value , Order ): ... return value ... else : ... raise Exception ( f \" { value !r} is not valid order\" ) >>> @dataclass ... class Purchase ( Story ): ... I . find_order ... ... def find_order ( self , state ): ... state . order = self . load_order ( state . order_id ) ... ... load_order : Callable >>> class PurchaseState ( State ): ... order_id = Argument ( is_order_id ) ... order = Variable ( is_order ) >>> purchase = Purchase ( load_order = load_order ) >>> state = PurchaseState ( order_id = 1 ) >>> purchase ( state ) >>> state . order_id 1 async >>> import asyncio >>> from dataclasses import dataclass >>> from typing import Coroutine >>> from stories import Story , I , State , Argument >>> from aioapp.repositories import load_order >>> from aioapp.entities import Order >>> def is_order_id ( value ): ... if isinstance ( value , int ): ... return value ... else : ... raise Exception ( f ' { value !r} is not valid order id' ) >>> def is_order ( value ): ... if isinstance ( value , Order ): ... return value ... else : ... raise Exception ( f ' { value !r} is not valid order' ) >>> @dataclass ... class Purchase ( Story ): ... I . find_order ... ... async def find_order ( self , state ): ... state . order = await self . load_order ( state . order_id ) ... ... load_order : Coroutine >>> class PurchaseState ( State ): ... order_id = Argument ( is_order_id ) ... order = Variable ( is_order ) >>> purchase = Purchase ( load_order = load_order ) >>> state = PurchaseState ( order_id = 1 ) >>> asyncio . run ( purchase ( state )) >>> state . order_id 1","title":"Constructor argument validates passed value"},{"location":"state/#validation-errors-are-propagated-as-usual-errors","text":"If validation function raises exception, story execution would stops. It would be propagated as usual exception which could happend inside the step. sync >>> from dataclasses import dataclass >>> from typing import Callable >>> from stories import Story , I , State , Variable >>> @dataclass ... class Purchase ( Story ): ... I . find_order ... ... def find_order ( self , state ): ... state . order = self . load_order ( order_id = 1 ) ... ... load_order : Callable >>> class PurchaseState ( State ): ... order = Variable ( is_order ) >>> purchase = Purchase ( load_order = lambda order_id : None ) >>> state = PurchaseState () >>> purchase ( state ) Traceback (most recent call last): ... Exception : None is not valid order async >>> import asyncio >>> from dataclasses import dataclass >>> from typing import Coroutine >>> from stories import Story , I , State , Variable >>> @dataclass ... class Purchase ( Story ): ... I . find_order ... ... async def find_order ( self , state ): ... state . order = await self . load_order ( order_id = 1 ) ... ... load_order : Coroutine >>> class PurchaseState ( State ): ... order = Variable ( is_order ) >>> async def load_order ( order_id ): ... pass >>> purchase = Purchase ( load_order = load_order ) >>> state = PurchaseState () >>> asyncio . run ( purchase ( state )) Traceback (most recent call last): ... Exception : None is not valid order","title":"Validation errors are propagated as usual errors"},{"location":"state/#validation-errors-would-be-raised-by-constructor","text":"If validation funcution raises exception, state constructor would propagate this error. sync >>> from dataclasses import dataclass >>> from typing import Callable >>> from stories import Story , I , State , Argument >>> from app.repositories import load_order >>> def is_order_id ( value ): ... if isinstance ( value , int ): ... return value ... else : ... raise Exception ( f \" { value !r} is not valid order id\" ) >>> @dataclass ... class Purchase ( Story ): ... I . find_order ... ... def find_order ( self , state ): ... state . order = self . load_order ( state . order_id ) ... ... load_order : Callable >>> class PurchaseState ( State ): ... order_id = Argument ( is_order_id ) >>> purchase = Purchase ( load_order = load_order ) >>> PurchaseState ( order_id = '1' ) Traceback (most recent call last): ... Exception : '1' is not valid order id async >>> from dataclasses import dataclass >>> from typing import Coroutine >>> from stories import Story , I , State , Argument >>> from aioapp.repositories import load_order >>> def is_order_id ( value ): ... if isinstance ( value , int ): ... return value ... else : ... raise Exception ( f ' { value !r} is not valid order id' ) >>> @dataclass ... class Purchase ( Story ): ... I . find_order ... ... async def find_order ( self , state ): ... state . order = await self . load_order ( state . order_id ) ... ... load_order : Coroutine >>> class PurchaseState ( State ): ... order_id = Argument ( is_order_id ) >>> purchase = Purchase ( load_order = load_order ) >>> PurchaseState ( order_id = '1' ) Traceback (most recent call last): ... Exception : '1' is not valid order id","title":"Validation errors would be raised by constructor"},{"location":"state/#validation-could-normalize-value","text":"Validator function could cast value passed to it to the new type. It's a similar process to normalization common to API schema libraries. To convert passed value to something new, just return new thing. New value returned by validator function would be assigned to the state attribute. This works both for Variable and Argument validators. sync >>> from dataclasses import dataclass >>> from typing import Callable >>> from stories import Story , I , State >>> from app.entities import Customer >>> def is_customer ( value ): ... if isinstance ( value , dict ) and value . keys () == { 'balance' } and isinstance ( value [ 'balance' ], int ): ... return Customer ( value [ 'balance' ]) ... else : ... raise Exception ( f ' { value !r} is not valid customer' ) >>> @dataclass ... class Purchase ( Story ): ... I . find_customer ... ... def find_customer ( self , state ): ... state . customer = self . load_customer ( customer_id = 1 ) ... ... load_customer : Callable >>> class PurchaseState ( State ): ... customer = Variable ( is_customer ) >>> def load_customer ( customer_id ): ... return { 'balance' : 100 } >>> purchase = Purchase ( load_customer = load_customer ) >>> state = PurchaseState () >>> purchase ( state ) >>> state . customer Customer(balance=100) async >>> import asyncio >>> from dataclasses import dataclass >>> from typing import Coroutine >>> from stories import Story , I , State , Variable >>> from app.entities import Customer >>> def is_customer ( value ): ... if isinstance ( value , dict ) and value . keys () == { 'balance' } and isinstance ( value [ 'balance' ], int ): ... return Customer ( value [ 'balance' ]) ... else : ... raise Exception ( f ' { value !r} is not valid customer' ) >>> @dataclass ... class Purchase ( Story ): ... I . find_customer ... ... async def find_customer ( self , state ): ... state . customer = await self . load_customer ( customer_id = 1 ) ... ... load_customer : Coroutine >>> class PurchaseState ( State ): ... customer = Variable ( is_customer ) >>> async def load_customer ( customer_id ): ... return { 'balance' : 100 } >>> purchase = Purchase ( load_customer = load_customer ) >>> state = PurchaseState () >>> asyncio . run ( purchase ( state )) >>> state . customer Customer(balance=100)","title":"Validation could normalize value"},{"location":"state/#state-union-joins-all-defined-variables","text":"Story composition requires complicated state object which would define variables necessary for both stories. If you defined separate state classes for both stories, you could join variables with State union operation. State union would include all variables defined in separate State classes. sync >>> from dataclasses import dataclass >>> from typing import Callable >>> from stories import Story , I , State , Variable , Union >>> from app.repositories import load_order , load_customer , create_payment >>> from app.entities import Order , Customer , Payment >>> def is_order ( value ): ... assert isinstance ( value , Order ) ... return value >>> def is_customer ( value ): ... assert isinstance ( value , Customer ) ... return value >>> def is_payment ( value ): ... assert isinstance ( value , Payment ) ... return value >>> @dataclass ... class Purchase ( Story ): ... I . find_order ... I . find_customer ... I . pay ... ... def find_order ( self , state ): ... state . order = self . load_order ( order_id = 1 ) ... ... def find_customer ( self , state ): ... state . customer = self . load_customer ( customer_id = 1 ) ... ... load_order : Callable ... load_customer : Callable ... pay : Story >>> @dataclass ... class Pay ( Story ): ... I . persist_payment ... ... def persist_payment ( self , state ): ... state . payment = self . create_payment ( ... order_id = 1 , customer_id = 1 ... ) ... ... create_payment : Callable >>> class PurchaseState ( State ): ... order = Variable ( is_order ) ... customer = Variable ( is_customer ) >>> class PayState ( State ): ... payment = Variable ( is_payment ) >>> pay = Pay ( create_payment = create_payment ) >>> purchase = Purchase ( ... load_order = load_order , ... load_customer = load_customer , ... pay = pay , ... ) >>> state_class = Union ( PurchaseState , PayState ) >>> state = state_class () >>> purchase ( state ) >>> state . payment Payment(due_date=datetime.datetime(1999, 12, 31, 0, 0)) async >>> import asyncio >>> from dataclasses import dataclass >>> from typing import Coroutine >>> from stories import Story , I , State , Variable , Union >>> from aioapp.repositories import load_order , load_customer , create_payment >>> from aioapp.entities import Order , Customer , Payment >>> def is_order ( value ): ... assert isinstance ( value , Order ) ... return value >>> def is_customer ( value ): ... assert isinstance ( value , Customer ) ... return value >>> def is_payment ( value ): ... assert isinstance ( value , Payment ) ... return value >>> @dataclass ... class Purchase ( Story ): ... I . find_order ... I . find_customer ... I . pay ... ... async def find_order ( self , state ): ... state . order = await self . load_order ( order_id = 1 ) ... ... async def find_customer ( self , state ): ... state . customer = await self . load_customer ( customer_id = 1 ) ... ... load_order : Callable ... load_customer : Callable ... pay : Story >>> @dataclass ... class Pay ( Story ): ... I . persist_payment ... ... async def persist_payment ( self , state ): ... state . payment = await self . create_payment ( ... order_id = 1 , customer_id = 1 ... ) ... ... create_payment : Callable >>> class PurchaseState ( State ): ... order = Variable ( is_order ) ... customer = Variable ( is_customer ) >>> class PayState ( State ): ... payment = Variable ( is_payment ) >>> pay = Pay ( create_payment = create_payment ) >>> purchase = Purchase ( ... load_order = load_order , ... load_customer = load_customer , ... pay = pay , ... ) >>> state_class = Union ( PurchaseState , PayState ) >>> state = state_class () >>> asyncio . run ( purchase ( state )) >>> state . payment Payment(due_date=datetime.datetime(1999, 12, 31, 0, 0))","title":"State union joins all defined variables"},{"location":"state/#state-union-joins-all-variable-validators","text":"Sometimes you would define variable with the same name in different state classes. Usually, these variables would have different validation functions. Since different stories has different requirements for them. When you create a composition of these stories, you expect all requirements to the variable would be satisfied. State union would call all validators of the variable at the moment of it assignment. If at least one validator fails, execution of the story stops on that error. sync >>> from dataclasses import dataclass >>> from datetime import datetime >>> from typing import Callable >>> from stories import Story , I , State , Variable , Union >>> from app.repositories import load_order , load_customer , create_payment >>> from app.entities import Order , Customer , Payment >>> def is_low_price ( order ): ... assert order . cost . amount < 500 ... return order >>> def is_recent_price ( order ): ... assert order . cost . at >= datetime ( 1999 , 1 , 1 ) ... return order >>> @dataclass ... class Purchase ( Story ): ... I . find_order ... I . find_customer ... I . pay ... ... def find_order ( self , state ): ... state . order = self . load_order ( order_id = 1 ) ... ... def find_customer ( self , state ): ... state . customer = self . load_customer ( customer_id = 1 ) ... ... load_order : Callable ... load_customer : Callable ... pay : Story >>> @dataclass ... class Pay ( Story ): ... I . persist_payment ... ... def persist_payment ( self , state ): ... state . payment = self . create_payment ( ... order_id = 1 , customer_id = 1 ... ) ... ... create_payment : Callable >>> class PurchaseState ( State ): ... order = Variable ( is_low_price ) ... customer = Variable () >>> class PayState ( State ): ... order = Variable ( is_recent_price ) ... payment = Variable () >>> pay = Pay ( create_payment = create_payment ) >>> purchase = Purchase ( ... load_order = load_order , ... load_customer = load_customer , ... pay = pay , ... ) >>> state_class = Union ( PurchaseState , PayState ) >>> state = state_class () >>> purchase ( state ) >>> state . order . cost Cost(at=datetime.datetime(1999, 12, 31, 0, 0), amount=7) async >>> import asyncio >>> from dataclasses import dataclass >>> from datetime import datetime >>> from typing import Coroutine >>> from stories import Story , I , State , Variable , Union >>> from aioapp.repositories import load_order , load_customer , create_payment >>> from aioapp.entities import Order , Customer , Payment >>> def is_low_price ( order ): ... assert order . cost . amount < 500 ... return order >>> def is_recent_price ( order ): ... assert order . cost . at >= datetime ( 1999 , 1 , 1 ) ... return order >>> @dataclass ... class Purchase ( Story ): ... I . find_order ... I . find_customer ... I . pay ... ... async def find_order ( self , state ): ... state . order = await self . load_order ( order_id = 1 ) ... ... async def find_customer ( self , state ): ... state . customer = await self . load_customer ( customer_id = 1 ) ... ... load_order : Callable ... load_customer : Callable ... pay : Story >>> @dataclass ... class Pay ( Story ): ... I . persist_payment ... ... async def persist_payment ( self , state ): ... state . payment = await self . create_payment ( ... order_id = 1 , customer_id = 1 ... ) ... ... create_payment : Callable >>> class PurchaseState ( State ): ... order = Variable ( is_low_price ) ... customer = Variable () >>> class PayState ( State ): ... order = Variable ( is_recent_price ) ... payment = Variable () >>> pay = Pay ( create_payment = create_payment ) >>> purchase = Purchase ( ... load_order = load_order , ... load_customer = load_customer , ... pay = pay , ... ) >>> state_class = Union ( PurchaseState , PayState ) >>> state = state_class () >>> asyncio . run ( purchase ( state )) >>> state . order . cost Cost(at=datetime.datetime(1999, 12, 31, 0, 0), amount=7) \u2014 \u2b50 \u2014","title":"State union joins all variable validators"},{"location":"story/","text":"Story \u00b6 Principles \u00b6 Story is a callable object Steps executed in specified order Steps could assign state variables Story state would be available after its execution Exceptions would be propagated Story is a callable object \u00b6 Story is an object which you should call if you want to execute story steps. When you inherit from Story class, you basically define __call__ and __repr__ methods on the class you own. It is nothing more than that under the hood. As you may notice, we don't require any specific way to instantiate the class. It's up to you whether or not to use libraries like attrs , dataclasses , pydantic or use plain __init__ method instead. attrs >>> from attr import attrs , attrib >>> from stories import Story , I >>> @attrs ... class Purchase ( Story ): ... I . find_order ... I . find_customer ... I . persist_payment ... ... def find_order ( self , state ): ... state . order = self . load_order ( state . order_id ) ... ... def find_customer ( self , state ): ... state . customer = self . load_customer ( state . customer_id ) ... ... def persist_payment ( self , state ): ... self . create_payment ( state . order_id , state . customer_id ) ... ... load_order = attrib () ... load_customer = attrib () ... create_payment = attrib () dataclasses >>> from dataclasses import dataclass >>> from typing import Callable >>> from stories import Story , I >>> @dataclass ... class Purchase ( Story ): ... I . find_order ... I . find_customer ... I . persist_payment ... ... def find_order ( self , state ): ... state . order = self . load_order ( state . order_id ) ... ... def find_customer ( self , state ): ... state . customer = self . load_customer ( state . customer_id ) ... ... def persist_payment ( self , state ): ... self . create_payment ( state . order_id , state . customer_id ) ... ... load_order : Callable ... load_customer : Callable ... create_payment : Callable pydantic >>> from typing import Callable >>> from pydantic.dataclasses import dataclass >>> from stories import Story , I >>> @dataclass ... class Purchase ( Story ): ... I . find_order ... I . find_customer ... I . persist_payment ... ... def find_order ( self , state ): ... state . order = self . load_order ( state . order_id ) ... ... def find_customer ( self , state ): ... state . customer = self . load_customer ( state . customer_id ) ... ... def persist_payment ( self , state ): ... self . create_payment ( state . order_id , state . customer_id ) ... ... load_order : Callable ... load_customer : Callable ... create_payment : Callable __init__ >>> from stories import Story , I >>> class Purchase ( Story ): ... I . find_order ... I . find_customer ... I . persist_payment ... ... def find_order ( self , state ): ... state . order = self . load_order ( state . order_id ) ... ... def find_customer ( self , state ): ... state . customer = self . load_customer ( state . customer_id ) ... ... def persist_payment ( self , state ): ... self . create_payment ( state . order_id , state . customer_id ) ... ... def __init__ ( self , load_order , load_customer , create_payment ): ... self . load_order = load_order ... self . load_customer = load_customer ... self . create_payment = create_payment Steps executed in specified order \u00b6 To call the story, you need to instantiate the class first. After that you could pass State object to the story call and story would be executed. If methods of the story are coroutines, you need to await story call as well. The same as you do with regular coroutine methods defined on your classes. sync >>> from dataclasses import dataclass >>> from typing import Callable >>> from stories import Story , I , State >>> from app.repositories import load_order , load_customer , create_payment >>> from app.tools import log >>> @dataclass ... class Purchase ( Story ): ... I . find_order ... I . find_customer ... I . check_balance ... I . persist_payment ... ... def find_order ( self , state ): ... self . log ( \"==> find order\" ) ... state . order = self . load_order ( state . order_id ) ... ... def find_customer ( self , state ): ... self . log ( \"==> find customer\" ) ... state . customer = self . load_customer ( state . customer_id ) ... ... def check_balance ( self , state ): ... self . log ( \"==> check balance\" ) ... if not state . order . affordable_for ( state . customer ): ... raise Exception ... ... def persist_payment ( self , state ): ... self . log ( \"==> persist payment\" ) ... state . payment = self . create_payment ( ... order_id = state . order_id , customer_id = state . customer_id ... ) ... ... log : Callable ... load_order : Callable ... load_customer : Callable ... create_payment : Callable >>> purchase = Purchase ( ... log = log , ... load_order = load_order , ... load_customer = load_customer , ... create_payment = create_payment , ... ) >>> state = State ( order_id = 1 , customer_id = 1 ) >>> purchase ( state ) ==> find order ==> find customer ==> check balance ==> persist payment async >>> import asyncio >>> from dataclasses import dataclass >>> from typing import Coroutine >>> from stories import Story , I , State >>> from aioapp.repositories import load_order , load_customer , create_payment >>> from aioapp.tools import log >>> @dataclass ... class Purchase ( Story ): ... I . find_order ... I . find_customer ... I . check_balance ... I . persist_payment ... ... async def find_order ( self , state ): ... await self . log ( \"==> find order\" ) ... state . order = await self . load_order ( state . order_id ) ... ... async def find_customer ( self , state ): ... await self . log ( \"==> find customer\" ) ... state . customer = await self . load_customer ( state . customer_id ) ... ... async def check_balance ( self , state ): ... await self . log ( \"==> check balance\" ) ... if not state . order . affordable_for ( state . customer ): ... raise Exception ... ... async def persist_payment ( self , state ): ... await self . log ( \"==> persist payment\" ) ... state . payment = await self . create_payment ( ... order_id = state . order_id , customer_id = state . customer_id ... ) ... ... log : Coroutine ... load_order : Coroutine ... load_customer : Coroutine ... create_payment : Coroutine >>> purchase = Purchase ( ... log = log , ... load_order = load_order , ... load_customer = load_customer , ... create_payment = create_payment , ... ) >>> state = State ( order_id = 1 , customer_id = 1 ) >>> asyncio . run ( purchase ( state )) ==> find order ==> find customer ==> check balance ==> persist payment Steps could assign state variables \u00b6 Every step could assign variable in state object. Story steps executed afterwards would be able to access variables assigned earlier. If you use plain State object, you could use any variable names. No restrictions applied to allowed name of the variable or its value. As you could see in the example below, the check_balance step is able to access order and customer variables set by previous steps. sync >>> from dataclasses import dataclass >>> from typing import Callable >>> from stories import Story , I , State >>> from app.repositories import load_order , load_customer , create_payment >>> @dataclass ... class Purchase ( Story ): ... I . find_order ... I . find_customer ... I . check_balance ... I . persist_payment ... ... def find_order ( self , state ): ... state . order = self . load_order ( state . order_id ) ... ... def find_customer ( self , state ): ... state . customer = self . load_customer ( state . customer_id ) ... ... def check_balance ( self , state ): ... if not state . order . affordable_for ( state . customer ): ... raise Exception ... ... def persist_payment ( self , state ): ... state . payment = self . create_payment ( ... order_id = state . order_id , customer_id = state . customer_id ... ) ... ... load_order : Callable ... load_customer : Callable ... create_payment : Callable >>> purchase = Purchase ( ... load_order = load_order , ... load_customer = load_customer , ... create_payment = create_payment , ... ) >>> state = State ( order_id = 1 , customer_id = 1 ) >>> purchase ( state ) async >>> import asyncio >>> from dataclasses import dataclass >>> from typing import Coroutine >>> from stories import Story , I , State >>> from aioapp.repositories import load_order , load_customer , create_payment >>> @dataclass ... class Purchase ( Story ): ... I . find_order ... I . find_customer ... I . check_balance ... I . persist_payment ... ... async def find_order ( self , state ): ... state . order = await self . load_order ( state . order_id ) ... ... async def find_customer ( self , state ): ... state . customer = await self . load_customer ( state . customer_id ) ... ... async def check_balance ( self , state ): ... if not state . order . affordable_for ( state . customer ): ... raise Exception ... ... async def persist_payment ( self , state ): ... state . payment = await self . create_payment ( ... order_id = state . order_id , customer_id = state . customer_id ... ) ... ... load_order : Coroutine ... load_customer : Coroutine ... create_payment : Coroutine >>> purchase = Purchase ( ... load_order = load_order , ... load_customer = load_customer , ... create_payment = create_payment , ... ) >>> state = State ( order_id = 1 , customer_id = 1 ) >>> asyncio . run ( purchase ( state )) Story state would be available after its execution \u00b6 After story execution all state variables would be available in the same state object you have passed to it. You would be able to access same objects that were assigned by story steps. sync >>> from dataclasses import dataclass >>> from typing import Callable >>> from stories import Story , I , State >>> from app.repositories import load_order , load_customer , create_payment >>> @dataclass ... class Purchase ( Story ): ... I . find_order ... I . find_customer ... I . persist_payment ... ... def find_order ( self , state ): ... state . order = self . load_order ( state . order_id ) ... ... def find_customer ( self , state ): ... state . customer = self . load_customer ( state . customer_id ) ... ... def persist_payment ( self , state ): ... state . payment = self . create_payment ( ... order_id = state . order_id , customer_id = state . customer_id ... ) ... ... load_order : Callable ... load_customer : Callable ... create_payment : Callable >>> purchase = Purchase ( ... load_order = load_order , ... load_customer = load_customer , ... create_payment = create_payment , ... ) >>> state = State ( order_id = 1 , customer_id = 1 ) >>> purchase ( state ) >>> state . order Order(product=Product(name='Books'), cost=Cost(at=datetime.datetime(1999, 12, 31, 0, 0), amount=7)) >>> state . order . product Product(name='Books') >>> state . customer Customer(balance=8) >>> state . payment Payment(due_date=datetime.datetime(1999, 12, 31, 0, 0)) async >>> import asyncio >>> from dataclasses import dataclass >>> from typing import Coroutine >>> from stories import Story , I , State >>> from aioapp.repositories import load_order , load_customer , create_payment >>> @dataclass ... class Purchase ( Story ): ... I . find_order ... I . find_customer ... I . persist_payment ... ... async def find_order ( self , state ): ... state . order = await self . load_order ( state . order_id ) ... ... async def find_customer ( self , state ): ... state . customer = await self . load_customer ( state . customer_id ) ... ... async def persist_payment ( self , state ): ... state . payment = await self . create_payment ( ... order_id = state . order_id , customer_id = state . customer_id ... ) ... ... load_order : Coroutine ... load_customer : Coroutine ... create_payment : Coroutine >>> purchase = Purchase ( ... load_order = load_order , ... load_customer = load_customer , ... create_payment = create_payment , ... ) >>> state = State ( order_id = 1 , customer_id = 1 ) >>> asyncio . run ( purchase ( state )) >>> state . order Order(product=Product(name='Books'), cost=Cost(at=datetime.datetime(1999, 12, 31, 0, 0), amount=7)) >>> state . order . product Product(name='Books') >>> state . customer Customer(balance=8) >>> state . payment Payment(due_date=datetime.datetime(1999, 12, 31, 0, 0)) Exceptions would be propagated \u00b6 If exception was raised inside the step method, execution of the story would stop at that moment and exception would be raised to the caller code without any changes. sync >>> from dataclasses import dataclass >>> from typing import Callable >>> from stories import Story , I , State >>> from app.tools import log >>> @dataclass ... class Purchase ( Story ): ... I . find_order ... I . find_customer ... I . check_balance ... I . persist_payment ... ... def find_order ( self , state ): ... self . log ( \"==> find order\" ) ... ... def find_customer ( self , state ): ... self . log ( \"==> find customer\" ) ... ... def check_balance ( self , state ): ... self . log ( \"==> check balance\" ) ... raise Exception ( \"Not enough money\" ) ... ... def persist_payment ( self , state ): ... self . log ( \"==> persist payment\" ) ... ... log : Callable >>> purchase = Purchase ( log = log ) >>> state = State () >>> try : ... purchase ( state ) ... except Exception as error : ... print ( f \"==> { error !r} \" ) ==> find order ==> find customer ==> check balance ==> Exception('Not enough money') async >>> import asyncio >>> from dataclasses import dataclass >>> from typing import Coroutine >>> from stories import Story , I , State >>> from aioapp.tools import log >>> @dataclass ... class Purchase ( Story ): ... I . find_order ... I . find_customer ... I . check_balance ... I . persist_payment ... ... async def find_order ( self , state ): ... await self . log ( \"==> find order\" ) ... ... async def find_customer ( self , state ): ... await self . log ( \"==> find customer\" ) ... ... async def check_balance ( self , state ): ... await self . log ( \"==> check balance\" ) ... raise Exception ( \"Not enough money\" ) ... ... async def persist_payment ( self , state ): ... await self . log ( \"==> persist payment\" ) ... ... log : Coroutine >>> purchase = Purchase ( log = log ) >>> state = State () >>> try : ... asyncio . run ( purchase ( state )) ... except Exception as error : ... print ( f \"==> { error !r} \" ) ==> find order ==> find customer ==> check balance ==> Exception('Not enough money') \u2014 \u2b50 \u2014","title":"Story"},{"location":"story/#story","text":"","title":"Story"},{"location":"story/#principles","text":"Story is a callable object Steps executed in specified order Steps could assign state variables Story state would be available after its execution Exceptions would be propagated","title":"Principles"},{"location":"story/#story-is-a-callable-object","text":"Story is an object which you should call if you want to execute story steps. When you inherit from Story class, you basically define __call__ and __repr__ methods on the class you own. It is nothing more than that under the hood. As you may notice, we don't require any specific way to instantiate the class. It's up to you whether or not to use libraries like attrs , dataclasses , pydantic or use plain __init__ method instead. attrs >>> from attr import attrs , attrib >>> from stories import Story , I >>> @attrs ... class Purchase ( Story ): ... I . find_order ... I . find_customer ... I . persist_payment ... ... def find_order ( self , state ): ... state . order = self . load_order ( state . order_id ) ... ... def find_customer ( self , state ): ... state . customer = self . load_customer ( state . customer_id ) ... ... def persist_payment ( self , state ): ... self . create_payment ( state . order_id , state . customer_id ) ... ... load_order = attrib () ... load_customer = attrib () ... create_payment = attrib () dataclasses >>> from dataclasses import dataclass >>> from typing import Callable >>> from stories import Story , I >>> @dataclass ... class Purchase ( Story ): ... I . find_order ... I . find_customer ... I . persist_payment ... ... def find_order ( self , state ): ... state . order = self . load_order ( state . order_id ) ... ... def find_customer ( self , state ): ... state . customer = self . load_customer ( state . customer_id ) ... ... def persist_payment ( self , state ): ... self . create_payment ( state . order_id , state . customer_id ) ... ... load_order : Callable ... load_customer : Callable ... create_payment : Callable pydantic >>> from typing import Callable >>> from pydantic.dataclasses import dataclass >>> from stories import Story , I >>> @dataclass ... class Purchase ( Story ): ... I . find_order ... I . find_customer ... I . persist_payment ... ... def find_order ( self , state ): ... state . order = self . load_order ( state . order_id ) ... ... def find_customer ( self , state ): ... state . customer = self . load_customer ( state . customer_id ) ... ... def persist_payment ( self , state ): ... self . create_payment ( state . order_id , state . customer_id ) ... ... load_order : Callable ... load_customer : Callable ... create_payment : Callable __init__ >>> from stories import Story , I >>> class Purchase ( Story ): ... I . find_order ... I . find_customer ... I . persist_payment ... ... def find_order ( self , state ): ... state . order = self . load_order ( state . order_id ) ... ... def find_customer ( self , state ): ... state . customer = self . load_customer ( state . customer_id ) ... ... def persist_payment ( self , state ): ... self . create_payment ( state . order_id , state . customer_id ) ... ... def __init__ ( self , load_order , load_customer , create_payment ): ... self . load_order = load_order ... self . load_customer = load_customer ... self . create_payment = create_payment","title":"Story is a callable object"},{"location":"story/#steps-executed-in-specified-order","text":"To call the story, you need to instantiate the class first. After that you could pass State object to the story call and story would be executed. If methods of the story are coroutines, you need to await story call as well. The same as you do with regular coroutine methods defined on your classes. sync >>> from dataclasses import dataclass >>> from typing import Callable >>> from stories import Story , I , State >>> from app.repositories import load_order , load_customer , create_payment >>> from app.tools import log >>> @dataclass ... class Purchase ( Story ): ... I . find_order ... I . find_customer ... I . check_balance ... I . persist_payment ... ... def find_order ( self , state ): ... self . log ( \"==> find order\" ) ... state . order = self . load_order ( state . order_id ) ... ... def find_customer ( self , state ): ... self . log ( \"==> find customer\" ) ... state . customer = self . load_customer ( state . customer_id ) ... ... def check_balance ( self , state ): ... self . log ( \"==> check balance\" ) ... if not state . order . affordable_for ( state . customer ): ... raise Exception ... ... def persist_payment ( self , state ): ... self . log ( \"==> persist payment\" ) ... state . payment = self . create_payment ( ... order_id = state . order_id , customer_id = state . customer_id ... ) ... ... log : Callable ... load_order : Callable ... load_customer : Callable ... create_payment : Callable >>> purchase = Purchase ( ... log = log , ... load_order = load_order , ... load_customer = load_customer , ... create_payment = create_payment , ... ) >>> state = State ( order_id = 1 , customer_id = 1 ) >>> purchase ( state ) ==> find order ==> find customer ==> check balance ==> persist payment async >>> import asyncio >>> from dataclasses import dataclass >>> from typing import Coroutine >>> from stories import Story , I , State >>> from aioapp.repositories import load_order , load_customer , create_payment >>> from aioapp.tools import log >>> @dataclass ... class Purchase ( Story ): ... I . find_order ... I . find_customer ... I . check_balance ... I . persist_payment ... ... async def find_order ( self , state ): ... await self . log ( \"==> find order\" ) ... state . order = await self . load_order ( state . order_id ) ... ... async def find_customer ( self , state ): ... await self . log ( \"==> find customer\" ) ... state . customer = await self . load_customer ( state . customer_id ) ... ... async def check_balance ( self , state ): ... await self . log ( \"==> check balance\" ) ... if not state . order . affordable_for ( state . customer ): ... raise Exception ... ... async def persist_payment ( self , state ): ... await self . log ( \"==> persist payment\" ) ... state . payment = await self . create_payment ( ... order_id = state . order_id , customer_id = state . customer_id ... ) ... ... log : Coroutine ... load_order : Coroutine ... load_customer : Coroutine ... create_payment : Coroutine >>> purchase = Purchase ( ... log = log , ... load_order = load_order , ... load_customer = load_customer , ... create_payment = create_payment , ... ) >>> state = State ( order_id = 1 , customer_id = 1 ) >>> asyncio . run ( purchase ( state )) ==> find order ==> find customer ==> check balance ==> persist payment","title":"Steps executed in specified order"},{"location":"story/#steps-could-assign-state-variables","text":"Every step could assign variable in state object. Story steps executed afterwards would be able to access variables assigned earlier. If you use plain State object, you could use any variable names. No restrictions applied to allowed name of the variable or its value. As you could see in the example below, the check_balance step is able to access order and customer variables set by previous steps. sync >>> from dataclasses import dataclass >>> from typing import Callable >>> from stories import Story , I , State >>> from app.repositories import load_order , load_customer , create_payment >>> @dataclass ... class Purchase ( Story ): ... I . find_order ... I . find_customer ... I . check_balance ... I . persist_payment ... ... def find_order ( self , state ): ... state . order = self . load_order ( state . order_id ) ... ... def find_customer ( self , state ): ... state . customer = self . load_customer ( state . customer_id ) ... ... def check_balance ( self , state ): ... if not state . order . affordable_for ( state . customer ): ... raise Exception ... ... def persist_payment ( self , state ): ... state . payment = self . create_payment ( ... order_id = state . order_id , customer_id = state . customer_id ... ) ... ... load_order : Callable ... load_customer : Callable ... create_payment : Callable >>> purchase = Purchase ( ... load_order = load_order , ... load_customer = load_customer , ... create_payment = create_payment , ... ) >>> state = State ( order_id = 1 , customer_id = 1 ) >>> purchase ( state ) async >>> import asyncio >>> from dataclasses import dataclass >>> from typing import Coroutine >>> from stories import Story , I , State >>> from aioapp.repositories import load_order , load_customer , create_payment >>> @dataclass ... class Purchase ( Story ): ... I . find_order ... I . find_customer ... I . check_balance ... I . persist_payment ... ... async def find_order ( self , state ): ... state . order = await self . load_order ( state . order_id ) ... ... async def find_customer ( self , state ): ... state . customer = await self . load_customer ( state . customer_id ) ... ... async def check_balance ( self , state ): ... if not state . order . affordable_for ( state . customer ): ... raise Exception ... ... async def persist_payment ( self , state ): ... state . payment = await self . create_payment ( ... order_id = state . order_id , customer_id = state . customer_id ... ) ... ... load_order : Coroutine ... load_customer : Coroutine ... create_payment : Coroutine >>> purchase = Purchase ( ... load_order = load_order , ... load_customer = load_customer , ... create_payment = create_payment , ... ) >>> state = State ( order_id = 1 , customer_id = 1 ) >>> asyncio . run ( purchase ( state ))","title":"Steps could assign state variables"},{"location":"story/#story-state-would-be-available-after-its-execution","text":"After story execution all state variables would be available in the same state object you have passed to it. You would be able to access same objects that were assigned by story steps. sync >>> from dataclasses import dataclass >>> from typing import Callable >>> from stories import Story , I , State >>> from app.repositories import load_order , load_customer , create_payment >>> @dataclass ... class Purchase ( Story ): ... I . find_order ... I . find_customer ... I . persist_payment ... ... def find_order ( self , state ): ... state . order = self . load_order ( state . order_id ) ... ... def find_customer ( self , state ): ... state . customer = self . load_customer ( state . customer_id ) ... ... def persist_payment ( self , state ): ... state . payment = self . create_payment ( ... order_id = state . order_id , customer_id = state . customer_id ... ) ... ... load_order : Callable ... load_customer : Callable ... create_payment : Callable >>> purchase = Purchase ( ... load_order = load_order , ... load_customer = load_customer , ... create_payment = create_payment , ... ) >>> state = State ( order_id = 1 , customer_id = 1 ) >>> purchase ( state ) >>> state . order Order(product=Product(name='Books'), cost=Cost(at=datetime.datetime(1999, 12, 31, 0, 0), amount=7)) >>> state . order . product Product(name='Books') >>> state . customer Customer(balance=8) >>> state . payment Payment(due_date=datetime.datetime(1999, 12, 31, 0, 0)) async >>> import asyncio >>> from dataclasses import dataclass >>> from typing import Coroutine >>> from stories import Story , I , State >>> from aioapp.repositories import load_order , load_customer , create_payment >>> @dataclass ... class Purchase ( Story ): ... I . find_order ... I . find_customer ... I . persist_payment ... ... async def find_order ( self , state ): ... state . order = await self . load_order ( state . order_id ) ... ... async def find_customer ( self , state ): ... state . customer = await self . load_customer ( state . customer_id ) ... ... async def persist_payment ( self , state ): ... state . payment = await self . create_payment ( ... order_id = state . order_id , customer_id = state . customer_id ... ) ... ... load_order : Coroutine ... load_customer : Coroutine ... create_payment : Coroutine >>> purchase = Purchase ( ... load_order = load_order , ... load_customer = load_customer , ... create_payment = create_payment , ... ) >>> state = State ( order_id = 1 , customer_id = 1 ) >>> asyncio . run ( purchase ( state )) >>> state . order Order(product=Product(name='Books'), cost=Cost(at=datetime.datetime(1999, 12, 31, 0, 0), amount=7)) >>> state . order . product Product(name='Books') >>> state . customer Customer(balance=8) >>> state . payment Payment(due_date=datetime.datetime(1999, 12, 31, 0, 0))","title":"Story state would be available after its execution"},{"location":"story/#exceptions-would-be-propagated","text":"If exception was raised inside the step method, execution of the story would stop at that moment and exception would be raised to the caller code without any changes. sync >>> from dataclasses import dataclass >>> from typing import Callable >>> from stories import Story , I , State >>> from app.tools import log >>> @dataclass ... class Purchase ( Story ): ... I . find_order ... I . find_customer ... I . check_balance ... I . persist_payment ... ... def find_order ( self , state ): ... self . log ( \"==> find order\" ) ... ... def find_customer ( self , state ): ... self . log ( \"==> find customer\" ) ... ... def check_balance ( self , state ): ... self . log ( \"==> check balance\" ) ... raise Exception ( \"Not enough money\" ) ... ... def persist_payment ( self , state ): ... self . log ( \"==> persist payment\" ) ... ... log : Callable >>> purchase = Purchase ( log = log ) >>> state = State () >>> try : ... purchase ( state ) ... except Exception as error : ... print ( f \"==> { error !r} \" ) ==> find order ==> find customer ==> check balance ==> Exception('Not enough money') async >>> import asyncio >>> from dataclasses import dataclass >>> from typing import Coroutine >>> from stories import Story , I , State >>> from aioapp.tools import log >>> @dataclass ... class Purchase ( Story ): ... I . find_order ... I . find_customer ... I . check_balance ... I . persist_payment ... ... async def find_order ( self , state ): ... await self . log ( \"==> find order\" ) ... ... async def find_customer ( self , state ): ... await self . log ( \"==> find customer\" ) ... ... async def check_balance ( self , state ): ... await self . log ( \"==> check balance\" ) ... raise Exception ( \"Not enough money\" ) ... ... async def persist_payment ( self , state ): ... await self . log ( \"==> persist payment\" ) ... ... log : Coroutine >>> purchase = Purchase ( log = log ) >>> state = State () >>> try : ... asyncio . run ( purchase ( state )) ... except Exception as error : ... print ( f \"==> { error !r} \" ) ==> find order ==> find customer ==> check balance ==> Exception('Not enough money') \u2014 \u2b50 \u2014","title":"Exceptions would be propagated"},{"location":"transactions/","text":"Transaction management \u00b6 It's possible to handle database transactions in different ways inside stories. Single steps \u00b6 If you need to wrap single story step in a database transaction, don't do that inside the step itself. Stories you write should not be aware of the database you use. Ideally, stories are written with composition in mind. You'll be able to decorate injected function in the construction process. >>> from dataclasses import dataclass >>> from typing import Callable >>> from stories import Story , I , State >>> @dataclass ... class Purchase ( Story ): ... I . lock_item ... I . charge_money ... I . notify_user ... ... def lock_item ( self , state ): ... self . lock_item_query () ... ... def charge_money ( self , state ): ... self . charge_money_query () ... ... def notify_user ( self , state ): ... self . send_notification ( state . user_id ) ... ... lock_item_query : Callable ... charge_money_query : Callable ... send_notification : Callable You don't need to wrap with transaction the step itself. It's better to wrap with transaction an injected functions. >>> from app.transactions import atomic >>> from app.repositories import lock_item_query , charge_money_query >>> from app.gateways import send_notification >>> purchase = Purchase ( ... lock_item_query = atomic ( lock_item_query ), ... charge_money_query = atomic ( charge_money_query ), ... send_notification = send_notification , ... ) >>> purchase ( State ( user_id = 1 )) BEGIN TRANSACTION; UPDATE 'items'; COMMIT TRANSACTION; BEGIN TRANSACTION; UPDATE 'balance'; COMMIT TRANSACTION; Whole story \u00b6 If you want to wrap the whole story in a single transaction, don't write special steps in the beginning and end of the story. We suggest to have single story with start and end of the transaction. This story would be able to decorate any story. Rollback will be handled at the same infrastructure level that compose decorated story. >>> from app.transactions import start_transaction , end_transaction , cancel_transaction >>> class Persistence : ... ... def __init__ ( self ): ... self . started = False ... self . committed = False ... ... def start_transaction ( self ): ... self . started = True ... start_transaction () ... ... def end_transaction ( self ): ... self . committed = True ... end_transaction () ... ... def finalize ( self ): ... if self . started and not self . committed : ... cancel_transaction () >>> @dataclass ... class Transactional ( Story ): ... I . begin ... I . wrapped ... I . end ... ... def begin ( self , state ): ... self . start_transaction () ... ... def end ( self , state ): ... self . end_transaction () ... ... start_transaction : Callable ... wrapped : Story ... end_transaction : Callable >>> persistence = Persistence () >>> purchase = Purchase ( ... lock_item_query = lock_item_query , ... charge_money_query = charge_money_query , ... send_notification = send_notification , ... ) >>> transactional = Transactional ( ... persistence . start_transaction , ... purchase , ... persistence . end_transaction , ... ) >>> try : ... transactional ( State ( user_id = 1 )) ... finally : ... persistence . finalize () BEGIN TRANSACTION; UPDATE 'items'; UPDATE 'balance'; COMMIT TRANSACTION; You would see transaction rolling back if nested story fails in the middle of its execution. Note As you may notice, Persistence is a stateful object. You need to create a dedicated instance of the story for each call! If you don't like such behavior consider to redesign Persistence class to store its flags in the State object. >>> from app.tools import log >>> persistence = Persistence () >>> transactional = Transactional ( ... persistence . start_transaction , ... purchase , ... persistence . end_transaction , ... ) >>> try : ... transactional ( State ( user_id = 2 )) ... except Exception : ... log ( \"ERROR\" ) ... finally : ... persistence . finalize () BEGIN TRANSACTION; UPDATE 'items'; UPDATE 'balance'; ERROR ROLLBACK TRANSACTION; \u2014 \u2b50 \u2014","title":"Transactions"},{"location":"transactions/#transaction-management","text":"It's possible to handle database transactions in different ways inside stories.","title":"Transaction management"},{"location":"transactions/#single-steps","text":"If you need to wrap single story step in a database transaction, don't do that inside the step itself. Stories you write should not be aware of the database you use. Ideally, stories are written with composition in mind. You'll be able to decorate injected function in the construction process. >>> from dataclasses import dataclass >>> from typing import Callable >>> from stories import Story , I , State >>> @dataclass ... class Purchase ( Story ): ... I . lock_item ... I . charge_money ... I . notify_user ... ... def lock_item ( self , state ): ... self . lock_item_query () ... ... def charge_money ( self , state ): ... self . charge_money_query () ... ... def notify_user ( self , state ): ... self . send_notification ( state . user_id ) ... ... lock_item_query : Callable ... charge_money_query : Callable ... send_notification : Callable You don't need to wrap with transaction the step itself. It's better to wrap with transaction an injected functions. >>> from app.transactions import atomic >>> from app.repositories import lock_item_query , charge_money_query >>> from app.gateways import send_notification >>> purchase = Purchase ( ... lock_item_query = atomic ( lock_item_query ), ... charge_money_query = atomic ( charge_money_query ), ... send_notification = send_notification , ... ) >>> purchase ( State ( user_id = 1 )) BEGIN TRANSACTION; UPDATE 'items'; COMMIT TRANSACTION; BEGIN TRANSACTION; UPDATE 'balance'; COMMIT TRANSACTION;","title":"Single steps"},{"location":"transactions/#whole-story","text":"If you want to wrap the whole story in a single transaction, don't write special steps in the beginning and end of the story. We suggest to have single story with start and end of the transaction. This story would be able to decorate any story. Rollback will be handled at the same infrastructure level that compose decorated story. >>> from app.transactions import start_transaction , end_transaction , cancel_transaction >>> class Persistence : ... ... def __init__ ( self ): ... self . started = False ... self . committed = False ... ... def start_transaction ( self ): ... self . started = True ... start_transaction () ... ... def end_transaction ( self ): ... self . committed = True ... end_transaction () ... ... def finalize ( self ): ... if self . started and not self . committed : ... cancel_transaction () >>> @dataclass ... class Transactional ( Story ): ... I . begin ... I . wrapped ... I . end ... ... def begin ( self , state ): ... self . start_transaction () ... ... def end ( self , state ): ... self . end_transaction () ... ... start_transaction : Callable ... wrapped : Story ... end_transaction : Callable >>> persistence = Persistence () >>> purchase = Purchase ( ... lock_item_query = lock_item_query , ... charge_money_query = charge_money_query , ... send_notification = send_notification , ... ) >>> transactional = Transactional ( ... persistence . start_transaction , ... purchase , ... persistence . end_transaction , ... ) >>> try : ... transactional ( State ( user_id = 1 )) ... finally : ... persistence . finalize () BEGIN TRANSACTION; UPDATE 'items'; UPDATE 'balance'; COMMIT TRANSACTION; You would see transaction rolling back if nested story fails in the middle of its execution. Note As you may notice, Persistence is a stateful object. You need to create a dedicated instance of the story for each call! If you don't like such behavior consider to redesign Persistence class to store its flags in the State object. >>> from app.tools import log >>> persistence = Persistence () >>> transactional = Transactional ( ... persistence . start_transaction , ... purchase , ... persistence . end_transaction , ... ) >>> try : ... transactional ( State ( user_id = 2 )) ... except Exception : ... log ( \"ERROR\" ) ... finally : ... persistence . finalize () BEGIN TRANSACTION; UPDATE 'items'; UPDATE 'balance'; ERROR ROLLBACK TRANSACTION; \u2014 \u2b50 \u2014","title":"Whole story"}]}